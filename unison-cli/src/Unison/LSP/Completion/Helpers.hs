module Unison.LSP.Completion.Helpers where

import Control.Comonad.Cofree
import Control.Lens hiding (List, (:<))
import Data.List.NonEmpty (NonEmpty (..))
import Data.Map qualified as Map
import Data.Set qualified as Set
import Data.Text qualified as Text
import Unison.Codebase.Path (Path)
import Unison.Codebase.Path qualified as Path
import Unison.LSP.Types
import Unison.LabeledDependency (LabeledDependency)
import Unison.LabeledDependency qualified as LD
import Unison.Name (Name)
import Unison.Name qualified as Name
import Unison.NameSegment (NameSegment (..))
import Unison.NameSegment qualified as NameSegment
import Unison.Names (Names (..))
import Unison.Prelude
import Unison.Util.Monoid qualified as Monoid
import Unison.Util.Relation qualified as Relation

-- | Generate a completion tree from a set of names.
-- A completion tree is a suffix tree over the path segments of each name it contains.
-- The goal is to allow fast completion of names by any partial path suffix.
--
-- The tree is generated by building a trie where all possible suffixes of a name are
-- reachable from the root of the trie, with sharing over subtrees to improve memory
-- residency.
--
-- Currently we don't "summarize" all of the children of a node in the node itself, and
-- instead you have to crawl all the children to get the actual completions.
--
-- TODO: Would it be worthwhile to perform compression or include child summaries on the suffix tree?
-- I suspect most namespace trees won't actually compress very well since each node is likely
-- to have terms/types at it.
--
-- E.g. From the names:
-- * alpha.beta.Nat
-- * alpha.Text
-- * foxtrot.Text
--
-- It will generate a tree like the following, where each bullet is a possible completion:
--
-- .
-- ├── foxtrot
-- │   └── Text
-- │       └── * foxtrot.Text (##Text)
-- ├── beta
-- │   └── Nat
-- │       └── * alpha.beta.Nat (##Nat)
-- ├── alpha
-- │   ├── beta
-- │   │   └── Nat
-- │   │       └── * alpha.beta.Nat (##Nat)
-- │   └── Text
-- │       └── * alpha.Text (##Text)
-- ├── Text
-- │   ├── * foxtrot.Text (##Text)
-- │   └── * alpha.Text (##Text)
-- └── Nat
--     └── * alpha.beta.Nat (##Nat)
namesToCompletionTree :: Names -> CompletionTree
namesToCompletionTree Names {terms, types} =
  let typeCompls =
        Relation.domain types
          & ifoldMap
            ( \name refs ->
                refs
                  & Monoid.whenM (not . isDefinitionDoc $ name)
                  & Set.map \ref -> (name, LD.typeRef ref)
            )
      termCompls =
        Relation.domain terms
          & ifoldMap
            ( \name refs ->
                refs
                  & Monoid.whenM (not . isDefinitionDoc $ name)
                  & Set.map \ref -> (name, LD.referent ref)
            )
   in foldMap (uncurry nameToCompletionTree) (typeCompls <> termCompls)
  where
    -- It's  annoying to see _all_ the definition docs in autocomplete so we filter them out.
    -- Special docs like "README" will still appear since they're not named 'doc'
    isDefinitionDoc name =
      case Name.reverseSegments name of
        ("doc" :| _) -> True
        _ -> False

nameToCompletionTree :: Name -> LabeledDependency -> CompletionTree
nameToCompletionTree name ref =
  let (lastSegment :| prefix) = Name.reverseSegments name
      complMap = helper (Map.singleton lastSegment (Set.singleton (name, ref) :< mempty)) prefix
   in CompletionTree (mempty :< complMap)
  where
    -- We build the tree bottom-up rather than top-down so we can take 'share' submaps for
    -- improved memory residency, each  call is passed the submap that we built under the
    -- current reversed path prefix.
    helper ::
      Map
        NameSegment
        (Cofree (Map NameSegment) (Set (Name, LabeledDependency))) ->
      [NameSegment] ->
      Map
        NameSegment
        (Cofree (Map NameSegment) (Set (Name, LabeledDependency)))
    helper subMap revPrefix = case revPrefix of
      [] -> subMap
      (ns : rest) ->
        mergeSubmaps (helper (Map.singleton ns (mempty :< subMap)) rest) subMap
      where
        mergeSubmaps = Map.unionWith (\a b -> unCompletionTree $ CompletionTree a <> CompletionTree b)

-- | Crawl the completion tree and return all valid prefix-based completions alongside their
-- Path from the provided prefix, and their full name.
--
-- E.g. if the term "alpha.beta.gamma.map (#abc)" exists in the completion map, and the query is "beta" the result would
-- be:
--
-- @@
-- [(["beta", "gamma", "map"], "alpha.beta.gamma.map", TermReferent #abc)]
-- @@
matchCompletions :: CompletionTree -> Text -> [(Path, Name, LabeledDependency)]
matchCompletions (CompletionTree tree) txt =
  matchSegments segments (Set.toList <$> tree)
  where
    segments :: [Text]
    segments =
      Text.splitOn "." txt
        & filter (not . Text.null)
    matchSegments :: [Text] -> Cofree (Map NameSegment) [(Name, LabeledDependency)] -> [(Path, Name, LabeledDependency)]
    matchSegments xs (currentMatches :< subtreeMap) =
      case xs of
        [] ->
          let current = currentMatches <&> (\(name, def) -> (Path.empty, name, def))
           in (current <> mkDefMatches subtreeMap)
        [prefix] ->
          Map.dropWhileAntitone ((< prefix) . NameSegment.toText) subtreeMap
            & Map.takeWhileAntitone (Text.isPrefixOf prefix . NameSegment.toText)
            & \matchingSubtrees ->
              let subMatches = ifoldMap (\ns subTree -> matchSegments [] subTree & consPathPrefix ns) matchingSubtrees
               in subMatches
        (ns : rest) ->
          foldMap (matchSegments rest) (Map.lookup (NameSegment ns) subtreeMap)
            & consPathPrefix (NameSegment ns)
    consPathPrefix :: NameSegment -> ([(Path, Name, LabeledDependency)]) -> [(Path, Name, LabeledDependency)]
    consPathPrefix ns = over (mapped . _1) (Path.cons ns)
    mkDefMatches :: Map NameSegment (Cofree (Map NameSegment) [(Name, LabeledDependency)]) -> [(Path, Name, LabeledDependency)]
    mkDefMatches xs = do
      (ns, (matches :< rest)) <- Map.toList xs
      let childMatches = mkDefMatches rest <&> over _1 (Path.cons ns)
      let currentMatches = matches <&> \(name, dep) -> (Path.singleton ns, name, dep)
      currentMatches <> childMatches
