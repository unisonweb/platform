module Unison.KindInference.Error.Pretty
  ( prettyKindError,
  )
where

import Unison.ABT qualified as ABT
import Unison.KindInference.Constraint.Pretty
import Unison.KindInference.Error (ConstraintConflict (..), KindError (..))
import Unison.KindInference.UVar (UVar (..))
import Unison.PrettyPrintEnv (PrettyPrintEnv)
import Unison.Type (Type)
import Unison.Util.AnnotatedText qualified as AT
import Unison.Util.ColorText (Color)
import Unison.Util.Pretty (ColorText, Pretty)
import Unison.Util.Pretty qualified as Pr
import Unison.Var (Var)

-- | Pretty print a user-facing @KindError@.
prettyKindError ::
  (Var v) =>
  -- | How to print types
  (Type v loc -> Pretty ColorText) ->
  -- | How to print source spans
  ([(loc, Color)] -> Pretty ColorText) ->
  -- | Contrasting colors used in error message output
  Color ->
  Color ->
  PrettyPrintEnv ->
  KindError v loc ->
  Pretty ColorText
prettyKindError prettyType showSource color1 color2 env = \case
  CycleDetected loc conflictedVar constraints ->
    let annotatedSrc =
          showSource
            [ (loc, color2)
            ]
        (prettyVarKind, prettyVarKindConstraint) = prettyCyclicUVarKind env constraints conflictedVar (stylePretty color1)
        theErrMsg =
          Pr.hang
            (Pr.bold "Cannot construct infinite kind")
            ( Pr.sep
                "\n"
                [ annotatedSrc,
                  Pr.wrap
                    ( "The above application constrains the kind of"
                        <> stylePretty color2 (prettyTyp conflictedVar)
                        <> "to be infinite, generated by the constraint"
                        <> prettyVarKindConstraint
                        <> "where"
                        <> stylePretty color1 prettyVarKind
                        <> "is the kind of"
                        <> Pr.group (stylePretty color2 (prettyTyp conflictedVar) <> ".")
                    )
                ]
            )
     in theErrMsg
  UnexpectedArgument _loc abs arg _constraints ->
    let theErrMsg =
          Pr.hang
            (Pr.bold "Kind mismatch arising from")
            ( Pr.sep
                "\n"
                [ annotatedSrc,
                  Pr.wrap
                    ( pabs
                        <> "doesn't expect an argument; however,"
                        <> "it is applied to"
                        <> Pr.group (parg <> ".")
                    )
                ]
            )
        annotatedSrc =
          showSource
            [ (varLoc abs, color1),
              (varLoc arg, color2)
            ]

        pabs = stylePretty color1 (prettyTyp abs)
        parg = stylePretty color2 (prettyTyp arg)
     in theErrMsg
  ArgumentMismatch abs expected actual constraints ->
    let theErrMsg =
          Pr.hang
            (Pr.bold "Kind mismatch arising from")
            ( Pr.sep
                "\n"
                [ annotatedSrc,
                  Pr.wrap
                    ( mconcat
                        [ pabs,
                          " expects an argument of kind: ",
                          Pr.group (stylePretty color1 (prettyUVarKind env constraints expected) <> ";"),
                          "however, it is applied to ",
                          parg,
                          "which has kind: ",
                          Pr.group (stylePretty color2 (prettyUVarKind env constraints actual) <> ".")
                        ]
                    )
                ]
            )
        annotatedSrc =
          showSource
            [ (varLoc abs, color1),
              (varLoc actual, color2)
            ]

        pabs = stylePretty color1 (prettyTyp abs)
        parg = stylePretty color2 (prettyTyp actual)
     in theErrMsg
  ArgumentMismatchArrow (_loc, _cod, _dom) ConstraintConflict' {conflictedVar, impliedConstraint, conflictedConstraint} constraints ->
    let theErrMsg =
          Pr.hang
            (Pr.bold "Kind mismatch arising from")
            ( Pr.sep
                "\n"
                [ annotatedSrc,
                  Pr.wrap
                    ( mconcat
                        [ "The arrow type",
                          Pr.group ("(" <> prettyArrow <> ")"),
                          "expects arguments of kind",
                          Pr.group (stylePretty color1 (prettySolvedConstraint env constraints impliedConstraint) <> ";"),
                          "however, it is applied to",
                          parg,
                          "which has kind:",
                          Pr.group (stylePretty color2 (prettySolvedConstraint env constraints conflictedConstraint) <> ".")
                        ]
                    )
                ]
            )
        prettyArrow = stylePretty color1 "->"
        annotatedSrc =
          showSource
            [ (varLoc conflictedVar, color2)
            ]

        parg = stylePretty color2 (prettyTyp conflictedVar)
     in theErrMsg
  EffectListMismatch ConstraintConflict' {conflictedVar, impliedConstraint, conflictedConstraint} constraints ->
    let theErrMsg =
          Pr.hang
            (Pr.bold "Kind mismatch arising from")
            ( Pr.sep
                "\n"
                [ annotatedSrc,
                  Pr.wrap
                    ( mconcat
                        [ "An ability list must consist solely of abilities;",
                          "however, this list contains",
                          parg,
                          "which has kind",
                          Pr.group (stylePretty color2 (prettySolvedConstraint env constraints conflictedConstraint) <> "."),
                          "Abilities are of kind ",
                          Pr.group (stylePretty color1 (prettySolvedConstraint env constraints impliedConstraint) <> ".")
                        ]
                    )
                ]
            )
        annotatedSrc =
          showSource
            [ (varLoc conflictedVar, color2)
            ]

        parg = stylePretty color2 (prettyTyp conflictedVar)
     in theErrMsg
  ConstraintConflict _generatedConstraint ConstraintConflict' {conflictedVar, impliedConstraint, conflictedConstraint} constraints ->
    let prettySolvedConstraint' c = Pr.bold (prettySolvedConstraint env constraints c)

        theErrMsg =
          Pr.hang
            (Pr.bold "Kind mismatch arising from")
            ( Pr.sep
                "\n"
                [ annotatedSrc,
                  "Expected kind: " <> stylePretty color1 (prettySolvedConstraint' impliedConstraint),
                  "Given kind: " <> stylePretty color2 (prettySolvedConstraint' conflictedConstraint)
                ]
            )
        annotatedSrc =
          showSource
            [ (varLoc conflictedVar, color2)
            ]
     in theErrMsg
  where
    varLoc var = ABT.annotation $ uvarType var
    prettyTyp = prettyType . uvarType

stylePretty :: Color -> Pretty ColorText -> Pretty ColorText
stylePretty = Pr.map . AT.annotate
