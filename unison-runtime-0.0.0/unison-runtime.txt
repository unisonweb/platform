-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-runtime
@version 0.0.0

module Unison.Runtime.Array

-- | A boxed, unlifted datatype representing a region of raw memory in the
--   garbage-collected heap, which is not scanned for pointers during
--   garbage collection.
--   
--   It is created by freezing a <a>MutableByteArray#</a> with
--   <a>unsafeFreezeByteArray#</a>. Freezing is essentially a no-op, as
--   <a>MutableByteArray#</a> and <a>ByteArray#</a> share the same heap
--   structure under the hood.
--   
--   The immutable and mutable variants are commonly used for scenarios
--   requiring high-performance data structures, like <tt>Text</tt>,
--   <tt>Primitive Vector</tt>, <tt>Unboxed Array</tt>, and
--   <tt>ShortByteString</tt>.
--   
--   Another application of fundamental importance is <tt>Integer</tt>,
--   which is backed by <a>ByteArray#</a>.
--   
--   The representation on the heap of a Byte Array is:
--   
--   <pre>
--   +------------+-----------------+-----------------------+
--   |            |                 |                       |
--   |   HEADER   | SIZE (in bytes) |       PAYLOAD         |
--   |            |                 |                       |
--   +------------+-----------------+-----------------------+
--   </pre>
--   
--   To obtain a pointer to actual payload (e.g., for FFI purposes) use
--   <a>byteArrayContents#</a> or <a>mutableByteArrayContents#</a>.
--   
--   Alternatively, enabling the <tt>UnliftedFFITypes</tt> extension allows
--   to mention <a>ByteArray#</a> and <a>MutableByteArray#</a> in FFI type
--   signatures directly.
data ByteArray# :: UnliftedType

-- | A mutable <tt>ByteAray#</tt>. It can be created in three ways:
--   
--   <ul>
--   <li><a>newByteArray#</a>: Create an unpinned array.</li>
--   <li><a>newPinnedByteArray#</a>: This will create a pinned array,</li>
--   <li><a>newAlignedPinnedByteArray#</a>: This will create a pinned
--   array, with a custom alignment.</li>
--   </ul>
--   
--   Unpinned arrays can be moved around during garbage collection, so you
--   must not store or pass pointers to these values if there is a chance
--   for the garbage collector to kick in. That said, even unpinned arrays
--   can be passed to unsafe FFI calls, because no garbage collection
--   happens during these unsafe calls (see <a>Guaranteed Call Safety</a>
--   in the GHC Manual). For safe FFI calls, byte arrays must be not only
--   pinned, but also kept alive by means of the keepAlive# function for
--   the duration of a call (that's because garbage collection cannot move
--   a pinned array, but is free to scrap it altogether).
data MutableByteArray# a :: UnliftedType

-- | Boxed arrays.
data () => Array a
Array :: Array# a -> Array a
[array#] :: Array a -> Array# a

-- | Lifted wrapper for <a>MutableByteArray#</a>.
--   
--   Since <a>MutableByteArray#</a> is an unlifted type and not a member of
--   kind <a>Type</a>, things like <tt>[MutableByteArray#]</tt> or <tt>IO
--   MutableByteArray#</tt> are ill-typed. To work around this
--   inconvenience this module provides a standard lifted wrapper,
--   inhabiting <a>Type</a>. Clients are expected to use
--   <a>MutableByteArray</a> in higher-level APIs, but wrap and unwrap
--   <a>MutableByteArray</a> internally as they please and use functions
--   from <a>GHC.Exts</a>.
data () => MutableByteArray s
MutableByteArray :: MutableByteArray# s -> MutableByteArray s

-- | Lifted wrapper for <a>ByteArray#</a>.
--   
--   Since <a>ByteArray#</a> is an unlifted type and not a member of kind
--   <a>Type</a>, things like <tt>[ByteArray#]</tt> or <tt>IO
--   ByteArray#</tt> are ill-typed. To work around this inconvenience this
--   module provides a standard lifted wrapper, inhabiting <a>Type</a>.
--   Clients are expected to use <a>ByteArray</a> in higher-level APIs, but
--   wrap and unwrap <a>ByteArray</a> internally as they please and use
--   functions from <a>GHC.Exts</a>.
data () => ByteArray
ByteArray :: ByteArray# -> ByteArray

-- | Mutable boxed arrays associated with a primitive state token.
data () => MutableArray s a
MutableArray :: MutableArray# s a -> MutableArray s a
[marray#] :: MutableArray s a -> MutableArray# s a

-- | Mutable primitive arrays associated with a primitive state token.
--   These can be written to and read from in a monadic context that
--   supports sequencing, such as <a>IO</a> or <a>ST</a>. Typically, a
--   mutable primitive array will be built and then converted to an
--   immutable primitive array using <a>unsafeFreezePrimArray</a>. However,
--   it is also acceptable to simply discard a mutable primitive array
--   since it lives in managed memory and will be garbage collected when no
--   longer referenced.
data () => MutablePrimArray s a
MutablePrimArray :: MutableByteArray# s -> MutablePrimArray s a

-- | Arrays of unboxed elements. This accepts types like <a>Double</a>,
--   <a>Char</a>, <a>Int</a> and <a>Word</a>, as well as their fixed-length
--   variants (<tt>Word8</tt>, <tt>Word16</tt>, etc.). Since the elements
--   are unboxed, a <a>PrimArray</a> is strict in its elements. This
--   differs from the behavior of <a>Array</a>, which is lazy in its
--   elements.
data () => PrimArray a
PrimArray :: ByteArray# -> PrimArray a

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | The empty <a>Array</a>.
emptyArray :: Array a

-- | Create a new mutable array of the specified size and initialise all
--   elements with the given value.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newArray :: PrimMonad m => Int -> a -> m (MutableArray (PrimState m) a)

-- | Create a new mutable byte array of the specified size in bytes.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Convert a mutable byte array to an immutable one without copying. The
--   array should not be modified after the conversion.
unsafeFreezeByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m ByteArray

-- | Size of the byte array in bytes.
sizeofByteArray :: ByteArray -> Int

-- | Create a <a>ByteArray</a> from a list of a known length. If the length
--   of the list does not match the given length, this throws an exception.
byteArrayFromListN :: Prim a => Int -> [a] -> ByteArray

-- | The empty <a>ByteArray</a>.
emptyByteArray :: ByteArray

-- | Copy a slice of a byte array to an unmanaged pointer address. These
--   must not overlap. The offset and length are given in elements, not in
--   bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyByteArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> ByteArray -> Int -> Int -> m ()

-- | Create a <i>pinned</i> byte array of the specified size in bytes. The
--   garbage collector is guaranteed not to move it.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newPinnedByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Fill a slice of a mutable byte array with a value. The offset and
--   length are given in elements of type <tt>a</tt> rather than in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
setByteArray :: (Prim a, PrimMonad m) => MutableByteArray (PrimState m) -> Int -> Int -> a -> m ()

-- | The number of elements in an immutable array.
sizeofArray :: Array a -> Int

-- | The number of elements in a mutable array.
sizeofMutableArray :: MutableArray s a -> Int

-- | Read a value from the immutable array at the given index.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArray :: Array a -> Int -> a

-- | Read a value from the immutable array at the given index, returning
--   the result in an unboxed unary tuple. This is currently used to
--   implement folds.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArray## :: Array a -> Int -> (# a #)

-- | Monadically read a value from the immutable array at the given index.
--   This allows us to be strict in the array while remaining lazy in the
--   read element which is very useful for collective operations. Suppose
--   we want to copy an array. We could do something like this:
--   
--   <pre>
--   copy marr arr ... = do ...
--                          writeArray marr i (indexArray arr i) ...
--                          ...
--   </pre>
--   
--   But since the arrays are lazy, the calls to <a>indexArray</a> will not
--   be evaluated. Rather, <tt>marr</tt> will be filled with thunks each of
--   which would retain a reference to <tt>arr</tt>. This is definitely not
--   what we want!
--   
--   With <a>indexArrayM</a>, we can instead write
--   
--   <pre>
--   copy marr arr ... = do ...
--                          x &lt;- indexArrayM arr i
--                          writeArray marr i x
--                          ...
--   </pre>
--   
--   Now, indexing is executed immediately although the returned element is
--   still not evaluated.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArrayM :: Monad m => Array a -> Int -> m a

-- | Create an immutable copy of a slice of an array.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezeArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (Array a)

-- | Convert a mutable array to an immutable one without copying. The array
--   should not be modified after the conversion.
unsafeFreezeArray :: PrimMonad m => MutableArray (PrimState m) a -> m (Array a)

-- | Create a mutable array from a slice of an immutable array.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawArray :: PrimMonad m => Array a -> Int -> Int -> m (MutableArray (PrimState m) a)

-- | Convert an immutable array to an mutable one without copying. The
--   immutable array should not be used after the conversion.
unsafeThawArray :: PrimMonad m => Array a -> m (MutableArray (PrimState m) a)

-- | Check whether the two arrays refer to the same memory block.
sameMutableArray :: MutableArray s a -> MutableArray s a -> Bool

-- | Return a newly allocated <a>Array</a> with the specified subrange of
--   the provided <a>Array</a>.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
cloneArray :: Array a -> Int -> Int -> Array a

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runArray m = runST $ m &gt;&gt;= unsafeFreezeArray
--   </pre>
runArray :: (forall s. () => ST s (MutableArray s a)) -> Array a

-- | Create an array of the given size with a default value, apply the
--   monadic function and freeze the result. If the size is 0, return
--   <a>emptyArray</a> (rather than a new copy thereof).
--   
--   <pre>
--   createArray 0 _ _ = emptyArray
--   createArray n x f = runArray $ do
--     mary &lt;- newArray n x
--     f mary
--     pure mary
--   </pre>
createArray :: Int -> a -> (forall s. () => MutableArray s a -> ST s ()) -> Array a

-- | This is the fastest, most straightforward way to traverse an array,
--   but it only works correctly with a sufficiently "affine"
--   <a>PrimMonad</a> instance. In particular, it must only produce
--   <i>one</i> result array. <a>ListT</a>-transformed monads, for example,
--   will not work right at all.
traverseArrayP :: PrimMonad m => (a -> m b) -> Array a -> m (Array b)

-- | Strict map over the elements of the array.
mapArray' :: (a -> b) -> Array a -> Array b

-- | Create an array from a list of a known length. If the length of the
--   list does not match the given length, this throws an exception.
arrayFromListN :: Int -> [a] -> Array a

-- | Create an array from a list.
arrayFromList :: [a] -> Array a

-- | Create a <i>pinned</i> byte array of the specified size in bytes and
--   with the given alignment. The garbage collector is guaranteed not to
--   move it.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newAlignedPinnedByteArray :: PrimMonad m => Int -> Int -> m (MutableByteArray (PrimState m))

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
byteArrayContents :: ByteArray -> Ptr Word8

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
mutableByteArrayContents :: MutableByteArray s -> Ptr Word8

-- | Check if the two arrays refer to the same memory block.
sameMutableByteArray :: MutableByteArray s -> MutableByteArray s -> Bool

-- | Resize a mutable byte array. The new size is given in bytes.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray</a> in case a new <a>MutableByteArray</a> had to
--   be allocated.
resizeMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m (MutableByteArray (PrimState m))

-- | Get the size of a byte array in bytes. Unlike
--   <a>sizeofMutableByteArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m Int

-- | Create an immutable copy of a slice of a byte array. The offset and
--   length are given in bytes.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezeByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> m ByteArray

-- | Create a mutable byte array from a slice of an immutable byte array.
--   The offset and length are given in bytes.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawByteArray :: PrimMonad m => ByteArray -> Int -> Int -> m (MutableByteArray (PrimState m))

-- | Convert an immutable byte array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawByteArray :: PrimMonad m => ByteArray -> m (MutableByteArray (PrimState m))

-- | Size of the mutable byte array in bytes. This function's behavior is
--   undefined if <a>resizeMutableByteArray</a> is ever called on the
--   mutable byte array given as the argument. Consequently, use of this
--   function is discouraged. Prefer <a>getSizeofMutableByteArray</a>,
--   which ensures correct sequencing in the presence of resizing.
sizeofMutableByteArray :: MutableByteArray s -> Int

-- | Shrink a mutable byte array. The new size is given in bytes. It must
--   be smaller than the old size. The array will be resized in place.
shrinkMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m ()

-- | Check whether or not the byte array is pinned. Pinned byte arrays
--   cannot be moved by the garbage collector. It is safe to use
--   <a>byteArrayContents</a> on such byte arrays.
--   
--   Caution: This function is only available when compiling with GHC 8.2
--   or newer.
isByteArrayPinned :: ByteArray -> Bool

-- | Check whether or not the mutable byte array is pinned.
--   
--   Caution: This function is only available when compiling with GHC 8.2
--   or newer.
isMutableByteArrayPinned :: MutableByteArray s -> Bool

-- | Right-fold over the elements of a <a>ByteArray</a>.
foldrByteArray :: Prim a => (a -> b -> b) -> b -> ByteArray -> b

-- | Create a <a>ByteArray</a> from a list.
--   
--   <pre>
--   byteArrayFromList xs = <a>byteArrayFromListN</a> (length xs) xs
--   </pre>
byteArrayFromList :: Prim a => [a] -> ByteArray

-- | Copy from an unmanaged pointer address to a byte array. These must not
--   overlap. The offset and length are given in elements, not in bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPtrToMutableByteArray :: (PrimMonad m, Prim a) => MutableByteArray (PrimState m) -> Int -> Ptr a -> Int -> m ()

-- | Copy a slice of a mutable byte array to an unmanaged pointer address.
--   These must not overlap. The offset and length are given in elements,
--   not in bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutableByteArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Copy a slice of a byte array to an unmanaged address. These must not
--   overlap.
--   
--   Note: This function is just <a>copyByteArrayToPtr</a> where <tt>a</tt>
--   is <a>Word8</a>.
copyByteArrayToAddr :: PrimMonad m => Ptr Word8 -> ByteArray -> Int -> Int -> m ()

-- | Copy a slice of a mutable byte array to an unmanaged address. These
--   must not overlap.
--   
--   Note: This function is just <a>copyMutableByteArrayToPtr</a> where
--   <tt>a</tt> is <a>Word8</a>.
copyMutableByteArrayToAddr :: PrimMonad m => Ptr Word8 -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Fill a slice of a mutable byte array with a byte.
--   
--   <i>Note:</i> this function does not do bounds checking.
fillByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> Word8 -> m ()

-- | Lexicographic comparison of equal-length slices into two byte arrays.
--   This wraps the <tt>compareByteArrays#</tt> primop, which wraps
--   <tt>memcmp</tt>.
compareByteArrays :: ByteArray -> Int -> ByteArray -> Int -> Int -> Ordering

-- | Return a newly allocated array with the specified subrange of the
--   provided array. The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
cloneByteArray :: ByteArray -> Int -> Int -> ByteArray

-- | Return a newly allocated mutable array with the specified subrange of
--   the provided mutable array. The provided mutable array should contain
--   the full subrange specified by the two Ints, but this is not checked.
cloneMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> m (MutableByteArray (PrimState m))

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runByteArray m = runST $ m &gt;&gt;= unsafeFreezeByteArray
--   </pre>
runByteArray :: (forall s. () => ST s (MutableByteArray s)) -> ByteArray

-- | Read an 8-bit element from the byte array, interpreting it as a
--   Latin-1-encoded character. The offset is given in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
readCharArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m Char

-- | Write a character to the byte array, encoding it with Latin-1 as a
--   single byte. Behavior is undefined for codepoints outside of the ASCII
--   and Latin-1 blocks. The offset is given in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
writeCharArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Char -> m ()

-- | Read an 8-bit element from the byte array, interpreting it as a
--   Latin-1-encoded character. The offset is given in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexCharArray :: ByteArray -> Int -> Char

-- | Create a <a>PrimArray</a> from a list.
--   
--   <pre>
--   primArrayFromList vs = <a>primArrayFromListN</a> (length vs) vs
--   </pre>
primArrayFromList :: Prim a => [a] -> PrimArray a

-- | Create a <a>PrimArray</a> from a list of a known length. If the length
--   of the list does not match the given length, this throws an exception.
primArrayFromListN :: Prim a => Int -> [a] -> PrimArray a

-- | Convert a <a>PrimArray</a> to a list.
primArrayToList :: Prim a => PrimArray a -> [a]

-- | The empty <a>PrimArray</a>.
emptyPrimArray :: PrimArray a

-- | Create a new mutable primitive array of the given length. The
--   underlying memory is left uninitialized.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Resize a mutable primitive array. The new size is given in elements.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutablePrimArray</a>
--   shall not be accessed anymore after a <a>resizeMutablePrimArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutablePrimArray</a> in case a new <a>MutablePrimArray</a> had to
--   be allocated.
resizeMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Shrink a mutable primitive array. The new size is given in elements.
--   It must be smaller than the old size. The array will be resized in
--   place.
shrinkMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m ()

-- | Copy part of a mutable array into another mutable array. In the case
--   that the destination and source arrays are the same, the regions may
--   overlap.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Copy part of an array into another mutable array.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> PrimArray a -> Int -> Int -> m ()

-- | Copy a slice of an immutable primitive array to a pointer. The offset
--   and length are given in elements of type <tt>a</tt>. This function
--   assumes that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPrimArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> PrimArray a -> Int -> Int -> m ()

-- | Copy a slice of a mutable primitive array to a pointer. The offset and
--   length are given in elements of type <tt>a</tt>. This function assumes
--   that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutablePrimArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Copy from a pointer to a mutable primitive array. The offset and
--   length are given in elements of type <tt>a</tt>. This function assumes
--   that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPtrToMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Ptr a -> Int -> m ()

-- | Fill a slice of a mutable primitive array with a value.
--   
--   <i>Note:</i> this function does not do bounds checking.
setPrimArray :: (Prim a, PrimMonad m) => MutablePrimArray (PrimState m) a -> Int -> Int -> a -> m ()

-- | Get the size of a mutable primitive array in elements. Unlike
--   <a>sizeofMutablePrimArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> m Int

-- | Size of the mutable primitive array in elements. This function shall
--   not be used on primitive arrays that are an argument to or a result of
--   <a>resizeMutablePrimArray</a> or <a>shrinkMutablePrimArray</a>.
sizeofMutablePrimArray :: forall s a. Prim a => MutablePrimArray s a -> Int

-- | Check if the two arrays refer to the same memory block.
sameMutablePrimArray :: MutablePrimArray s a -> MutablePrimArray s a -> Bool

-- | Create an immutable copy of a slice of a primitive array. The offset
--   and length are given in elements.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Int -> m (PrimArray a)

-- | Create a mutable primitive array from a slice of an immutable
--   primitive array. The offset and length are given in elements.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawPrimArray :: (PrimMonad m, Prim a) => PrimArray a -> Int -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Convert a mutable primitive array to an immutable one without copying.
--   The array should not be modified after the conversion.
unsafeFreezePrimArray :: PrimMonad m => MutablePrimArray (PrimState m) a -> m (PrimArray a)

-- | Convert an immutable array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawPrimArray :: PrimMonad m => PrimArray a -> m (MutablePrimArray (PrimState m) a)

-- | Get the size, in elements, of the primitive array.
sizeofPrimArray :: Prim a => PrimArray a -> Int

-- | Check whether or not the primitive array is pinned. Pinned primitive
--   arrays cannot be moved by the garbage collector. It is safe to use
--   <a>primArrayContents</a> on such arrays. This function is only
--   available when compiling with GHC 8.2 or newer.
isPrimArrayPinned :: PrimArray a -> Bool

-- | Check whether or not the mutable primitive array is pinned. This
--   function is only available when compiling with GHC 8.2 or newer.
isMutablePrimArrayPinned :: MutablePrimArray s a -> Bool

-- | Lazy right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray :: Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Strict right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray' :: Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Lazy left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray :: Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray' :: Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArrayM' :: (Prim a, Monad m) => (b -> a -> m b) -> b -> PrimArray a -> m b

-- | Traverse a primitive array. The traversal forces the resulting values
--   and writes them to the new primitive array as it performs the monadic
--   effects. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArrayP (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   In many situations, <a>traversePrimArrayP</a> can replace
--   <a>traversePrimArray</a>, changing the strictness characteristics of
--   the traversal but typically improving the performance. Consider the
--   following short-circuiting traversal:
--   
--   <pre>
--   incrPositiveA :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveA xs = traversePrimArray (\x -&gt; bool Nothing (Just (x + 1)) (x &gt; 0)) xs
--   </pre>
--   
--   This can be rewritten using <a>traversePrimArrayP</a>. To do this, we
--   must change the traversal context to <tt>MaybeT (ST s)</tt>, which has
--   a <a>PrimMonad</a> instance:
--   
--   <pre>
--   incrPositiveB :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveB xs = runST $ runMaybeT $ traversePrimArrayP
--     (\x -&gt; bool (MaybeT (return Nothing)) (MaybeT (return (Just (x + 1)))) (x &gt; 0))
--     xs
--   </pre>
--   
--   Benchmarks demonstrate that the second implementation runs 150 times
--   faster than the first. It also results in fewer allocations.
traversePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates to true.
filterPrimArrayP :: (PrimMonad m, Prim a) => (a -> m Bool) -> PrimArray a -> m (PrimArray a)

-- | Map over the primitive array, keeping the elements for which the
--   monadic predicate provides a <a>Just</a>.
mapMaybePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m (Maybe b)) -> PrimArray a -> m (PrimArray b)

-- | Generate a primitive array by evaluating the monadic generator
--   function at each index.
generatePrimArrayP :: (PrimMonad m, Prim a) => Int -> (Int -> m a) -> m (PrimArray a)

-- | Execute the monadic action the given number of times and store the
--   results in a primitive array.
replicatePrimArrayP :: (PrimMonad m, Prim a) => Int -> m a -> m (PrimArray a)

-- | Map over the elements of a primitive array.
mapPrimArray :: (Prim a, Prim b) => (a -> b) -> PrimArray a -> PrimArray b

-- | Indexed map over the elements of a primitive array.
imapPrimArray :: (Prim a, Prim b) => (Int -> a -> b) -> PrimArray a -> PrimArray b

-- | Filter elements of a primitive array according to a predicate.
filterPrimArray :: Prim a => (a -> Bool) -> PrimArray a -> PrimArray a

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates true.
filterPrimArrayA :: (Applicative f, Prim a) => (a -> f Bool) -> PrimArray a -> f (PrimArray a)

-- | Map over the primitive array, keeping the elements for which the
--   applicative predicate provides a <a>Just</a>.
mapMaybePrimArrayA :: (Applicative f, Prim a, Prim b) => (a -> f (Maybe b)) -> PrimArray a -> f (PrimArray b)

-- | Map over a primitive array, optionally discarding some elements. This
--   has the same behavior as <tt>Data.Maybe.mapMaybe</tt>.
mapMaybePrimArray :: (Prim a, Prim b) => (a -> Maybe b) -> PrimArray a -> PrimArray b

-- | Traverse a primitive array. The traversal performs all of the
--   applicative effects <i>before</i> forcing the resulting values and
--   writing them to the new primitive array. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArray (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   3
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   The function <a>traversePrimArrayP</a> always outperforms this
--   function, but it requires a <a>PrimMonad</a> constraint, and it forces
--   the values as it performs the effects.
traversePrimArray :: (Applicative f, Prim a, Prim b) => (a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Traverse a primitive array with the index of each element.
itraversePrimArray :: (Applicative f, Prim a, Prim b) => (Int -> a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Traverse a primitive array with the indices. The traversal forces the
--   resulting values and writes them to the new primitive array as it
--   performs the monadic effects.
itraversePrimArrayP :: (Prim a, Prim b, PrimMonad m) => (Int -> a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Generate a primitive array.
generatePrimArray :: Prim a => Int -> (Int -> a) -> PrimArray a

-- | Create a primitive array by copying the element the given number of
--   times.
replicatePrimArray :: Prim a => Int -> a -> PrimArray a

-- | Generate a primitive array by evaluating the applicative generator
--   function at each index.
generatePrimArrayA :: (Applicative f, Prim a) => Int -> (Int -> f a) -> f (PrimArray a)

-- | Execute the applicative action the given number of times and store the
--   results in a <a>PrimArray</a>.
replicatePrimArrayA :: (Applicative f, Prim a) => Int -> f a -> f (PrimArray a)

-- | Traverse the primitive array, discarding the results. There is no
--   <a>PrimMonad</a> variant of this function, since it would not provide
--   any performance benefit.
traversePrimArray_ :: (Applicative f, Prim a) => (a -> f b) -> PrimArray a -> f ()

-- | Traverse the primitive array with the indices, discarding the results.
--   There is no <a>PrimMonad</a> variant of this function, since it would
--   not provide any performance benefit.
itraversePrimArray_ :: (Applicative f, Prim a) => (Int -> a -> f b) -> PrimArray a -> f ()

-- | Create a <i>pinned</i> primitive array of the specified size (in
--   elements). The garbage collector is guaranteed not to move it.
newPinnedPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Create a <i>pinned</i> primitive array of the specified size (in
--   elements) and with the alignment given by its <a>Prim</a> instance.
--   The garbage collector is guaranteed not to move it.
newAlignedPinnedPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> prim arrays allocated by <tt>newPinnedByteArray</tt> or
--   <tt>newAlignedPinnedByteArray</tt>.
primArrayContents :: PrimArray a -> Ptr a

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <tt>newPinnedByteArray</tt> or
--   <tt>newAlignedPinnedByteArray</tt>.
mutablePrimArrayContents :: MutablePrimArray s a -> Ptr a

-- | Return a newly allocated array with the specified subrange of the
--   provided array. The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
clonePrimArray :: Prim a => PrimArray a -> Int -> Int -> PrimArray a

-- | Return a newly allocated mutable array with the specified subrange of
--   the provided mutable array. The provided mutable array should contain
--   the full subrange specified by the two Ints, but this is not checked.
cloneMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runPrimArray m = runST $ m &gt;&gt;= unsafeFreezePrimArray
--   </pre>
runPrimArray :: (forall s. () => ST s (MutablePrimArray s a)) -> PrimArray a
byteArrayToList :: ByteArray -> [Word8]
readArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> m a
writeArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> a -> m ()
copyArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> Array a -> Int -> Int -> m ()
copyMutableArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> MutableArray (PrimState m) a -> Int -> Int -> m ()
cloneMutableArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (MutableArray (PrimState m) a)
readByteArray :: forall a m. CheckCtx => PrimMonad m => Prim a => MutableByteArray (PrimState m) -> Int -> m a
writeByteArray :: forall a m. CheckCtx => PrimMonad m => Prim a => MutableByteArray (PrimState m) -> Int -> a -> m ()
indexByteArray :: forall a. CheckCtx => Prim a => ByteArray -> Int -> a
copyByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> ByteArray -> Int -> Int -> m ()
copyMutableByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()
moveByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()
readPrimArray :: CheckCtx => PrimMonad m => Prim a => MutablePrimArray (PrimState m) a -> Int -> m a
writePrimArray :: CheckCtx => PrimMonad m => Prim a => MutablePrimArray (PrimState m) a -> Int -> a -> m ()
indexPrimArray :: CheckCtx => Prim a => PrimArray a -> Int -> a

module Unison.Runtime.Builtin.Types
typeReferences :: [(Reference, Word64)]
builtinTypeNumbering :: Map Reference Word64
builtinTypeBackref :: EnumMap Word64 Reference

module Unison.Runtime.Crypto.Rsa

-- | Parse a RSA public key from a ByteString The input bytestring is a
--   hex-encoded string of the DER file for the public key. It can be
--   generated with those commands: # generate a RSA key of a given size
--   openssl genrsa -out private_key.pem <a>size</a> # output the DER
--   format as a hex string openssl rsa -in private_key.pem -outform DER
--   -pubout | xxd -p
parseRsaPublicKey :: ByteString -> Either Text PublicKey

-- | Parse a RSA private key from a ByteString The input bytestring is a
--   hex-encoded string of the DER file for the private key. It can be
--   generated with those commands: # generate a RSA key of a given size
--   openssl genrsa -out private_key.pem <a>size</a> # output the DER
--   format as a hex string openssl rsa -in private_key.pem -outform DER |
--   xxd -p
parseRsaPrivateKey :: ByteString -> Either Text PrivateKey

-- | Display a RSA Error
rsaErrorToText :: Error -> Text

module Unison.Runtime.Foreign.Function.Type

-- | Enum representing every foreign call.
data ForeignFunc
IO_UDP_clientSocket_impl_v1 :: ForeignFunc
IO_UDP_UDPSocket_recv_impl_v1 :: ForeignFunc
IO_UDP_UDPSocket_send_impl_v1 :: ForeignFunc
IO_UDP_UDPSocket_close_impl_v1 :: ForeignFunc
IO_UDP_ListenSocket_close_impl_v1 :: ForeignFunc
IO_UDP_UDPSocket_toText_impl_v1 :: ForeignFunc
IO_UDP_serverSocket_impl_v1 :: ForeignFunc
IO_UDP_ListenSocket_toText_impl_v1 :: ForeignFunc
IO_UDP_ListenSocket_recvFrom_impl_v1 :: ForeignFunc
IO_UDP_ClientSockAddr_toText_v1 :: ForeignFunc
IO_UDP_ListenSocket_sendTo_impl_v1 :: ForeignFunc
IO_openFile_impl_v3 :: ForeignFunc
IO_closeFile_impl_v3 :: ForeignFunc
IO_isFileEOF_impl_v3 :: ForeignFunc
IO_isFileOpen_impl_v3 :: ForeignFunc
IO_getEcho_impl_v1 :: ForeignFunc
IO_ready_impl_v1 :: ForeignFunc
IO_getChar_impl_v1 :: ForeignFunc
IO_isSeekable_impl_v3 :: ForeignFunc
IO_seekHandle_impl_v3 :: ForeignFunc
IO_handlePosition_impl_v3 :: ForeignFunc
IO_getBuffering_impl_v3 :: ForeignFunc
IO_setBuffering_impl_v3 :: ForeignFunc
IO_setEcho_impl_v1 :: ForeignFunc
IO_getLine_impl_v1 :: ForeignFunc
IO_getBytes_impl_v3 :: ForeignFunc
IO_getSomeBytes_impl_v1 :: ForeignFunc
IO_putBytes_impl_v3 :: ForeignFunc
IO_systemTime_impl_v3 :: ForeignFunc
IO_systemTimeMicroseconds_v1 :: ForeignFunc
Clock_internals_monotonic_v1 :: ForeignFunc
Clock_internals_realtime_v1 :: ForeignFunc
Clock_internals_processCPUTime_v1 :: ForeignFunc
Clock_internals_threadCPUTime_v1 :: ForeignFunc
Clock_internals_sec_v1 :: ForeignFunc
Clock_internals_nsec_v1 :: ForeignFunc
Clock_internals_systemTimeZone_v1 :: ForeignFunc
IO_getTempDirectory_impl_v3 :: ForeignFunc
IO_createTempDirectory_impl_v3 :: ForeignFunc
IO_getCurrentDirectory_impl_v3 :: ForeignFunc
IO_setCurrentDirectory_impl_v3 :: ForeignFunc
IO_fileExists_impl_v3 :: ForeignFunc
IO_getEnv_impl_v1 :: ForeignFunc
IO_getArgs_impl_v1 :: ForeignFunc
IO_isDirectory_impl_v3 :: ForeignFunc
IO_createDirectory_impl_v3 :: ForeignFunc
IO_removeDirectory_impl_v3 :: ForeignFunc
IO_renameDirectory_impl_v3 :: ForeignFunc
IO_directoryContents_impl_v3 :: ForeignFunc
IO_removeFile_impl_v3 :: ForeignFunc
IO_renameFile_impl_v3 :: ForeignFunc
IO_getFileTimestamp_impl_v3 :: ForeignFunc
IO_getFileSize_impl_v3 :: ForeignFunc
IO_serverSocket_impl_v3 :: ForeignFunc
Socket_toText :: ForeignFunc
Handle_toText :: ForeignFunc
ThreadId_toText :: ForeignFunc
IO_socketPort_impl_v3 :: ForeignFunc
IO_listen_impl_v3 :: ForeignFunc
IO_clientSocket_impl_v3 :: ForeignFunc
IO_closeSocket_impl_v3 :: ForeignFunc
IO_socketAccept_impl_v3 :: ForeignFunc
IO_socketSend_impl_v3 :: ForeignFunc
IO_socketReceive_impl_v3 :: ForeignFunc
IO_kill_impl_v3 :: ForeignFunc
IO_delay_impl_v3 :: ForeignFunc
IO_stdHandle :: ForeignFunc
IO_process_call :: ForeignFunc
IO_process_start :: ForeignFunc
IO_process_kill :: ForeignFunc
IO_process_wait :: ForeignFunc
IO_process_exitCode :: ForeignFunc
MVar_new :: ForeignFunc
MVar_newEmpty_v2 :: ForeignFunc
MVar_take_impl_v3 :: ForeignFunc
MVar_tryTake :: ForeignFunc
MVar_put_impl_v3 :: ForeignFunc
MVar_tryPut_impl_v3 :: ForeignFunc
MVar_swap_impl_v3 :: ForeignFunc
MVar_isEmpty :: ForeignFunc
MVar_read_impl_v3 :: ForeignFunc
MVar_tryRead_impl_v3 :: ForeignFunc
Char_toText :: ForeignFunc
Text_repeat :: ForeignFunc
Text_reverse :: ForeignFunc
Text_toUppercase :: ForeignFunc
Text_toLowercase :: ForeignFunc
Text_toUtf8 :: ForeignFunc
Text_fromUtf8_impl_v3 :: ForeignFunc
Tls_ClientConfig_default :: ForeignFunc
Tls_ServerConfig_default :: ForeignFunc
Tls_ClientConfig_certificates_set :: ForeignFunc
Tls_ServerConfig_certificates_set :: ForeignFunc
TVar_new :: ForeignFunc
TVar_read :: ForeignFunc
TVar_write :: ForeignFunc
TVar_newIO :: ForeignFunc
TVar_readIO :: ForeignFunc
TVar_swap :: ForeignFunc
STM_retry :: ForeignFunc
Promise_new :: ForeignFunc
Promise_read :: ForeignFunc
Promise_tryRead :: ForeignFunc
Promise_write :: ForeignFunc
Tls_newClient_impl_v3 :: ForeignFunc
Tls_newServer_impl_v3 :: ForeignFunc
Tls_handshake_impl_v3 :: ForeignFunc
Tls_send_impl_v3 :: ForeignFunc
Tls_decodeCert_impl_v3 :: ForeignFunc
Tls_encodeCert :: ForeignFunc
Tls_decodePrivateKey :: ForeignFunc
Tls_encodePrivateKey :: ForeignFunc
Tls_receive_impl_v3 :: ForeignFunc
Tls_terminate_impl_v3 :: ForeignFunc
Code_validateLinks :: ForeignFunc
Code_dependencies :: ForeignFunc
Code_serialize :: ForeignFunc
Code_deserialize :: ForeignFunc
Code_display :: ForeignFunc
Value_dependencies :: ForeignFunc
Value_serialize :: ForeignFunc
Value_deserialize :: ForeignFunc
Crypto_HashAlgorithm_Sha3_512 :: ForeignFunc
Crypto_HashAlgorithm_Sha3_256 :: ForeignFunc
Crypto_HashAlgorithm_Sha2_512 :: ForeignFunc
Crypto_HashAlgorithm_Sha2_256 :: ForeignFunc
Crypto_HashAlgorithm_Sha1 :: ForeignFunc
Crypto_HashAlgorithm_Blake2b_512 :: ForeignFunc
Crypto_HashAlgorithm_Blake2b_256 :: ForeignFunc
Crypto_HashAlgorithm_Blake2s_256 :: ForeignFunc
Crypto_HashAlgorithm_Md5 :: ForeignFunc
Crypto_hashBytes :: ForeignFunc
Crypto_hmacBytes :: ForeignFunc
Crypto_hash :: ForeignFunc
Crypto_hmac :: ForeignFunc
Crypto_Ed25519_sign_impl :: ForeignFunc
Crypto_Ed25519_verify_impl :: ForeignFunc
Crypto_Rsa_sign_impl :: ForeignFunc
Crypto_Rsa_verify_impl :: ForeignFunc
Universal_murmurHash :: ForeignFunc
IO_randomBytes :: ForeignFunc
Bytes_zlib_compress :: ForeignFunc
Bytes_gzip_compress :: ForeignFunc
Bytes_zlib_decompress :: ForeignFunc
Bytes_gzip_decompress :: ForeignFunc
Bytes_toBase16 :: ForeignFunc
Bytes_toBase32 :: ForeignFunc
Bytes_toBase64 :: ForeignFunc
Bytes_toBase64UrlUnpadded :: ForeignFunc
Bytes_fromBase16 :: ForeignFunc
Bytes_fromBase32 :: ForeignFunc
Bytes_fromBase64 :: ForeignFunc
Bytes_fromBase64UrlUnpadded :: ForeignFunc
Bytes_decodeNat64be :: ForeignFunc
Bytes_decodeNat64le :: ForeignFunc
Bytes_decodeNat32be :: ForeignFunc
Bytes_decodeNat32le :: ForeignFunc
Bytes_decodeNat16be :: ForeignFunc
Bytes_decodeNat16le :: ForeignFunc
Bytes_encodeNat64be :: ForeignFunc
Bytes_encodeNat64le :: ForeignFunc
Bytes_encodeNat32be :: ForeignFunc
Bytes_encodeNat32le :: ForeignFunc
Bytes_encodeNat16be :: ForeignFunc
Bytes_encodeNat16le :: ForeignFunc
MutableArray_copyTo_force :: ForeignFunc
MutableByteArray_copyTo_force :: ForeignFunc
ImmutableArray_copyTo_force :: ForeignFunc
ImmutableArray_size :: ForeignFunc
MutableArray_size :: ForeignFunc
ImmutableByteArray_size :: ForeignFunc
MutableByteArray_size :: ForeignFunc
ImmutableByteArray_copyTo_force :: ForeignFunc
MutableArray_read :: ForeignFunc
MutableByteArray_read8 :: ForeignFunc
MutableByteArray_read16be :: ForeignFunc
MutableByteArray_read24be :: ForeignFunc
MutableByteArray_read32be :: ForeignFunc
MutableByteArray_read40be :: ForeignFunc
MutableByteArray_read64be :: ForeignFunc
MutableArray_write :: ForeignFunc
MutableByteArray_write8 :: ForeignFunc
MutableByteArray_write16be :: ForeignFunc
MutableByteArray_write32be :: ForeignFunc
MutableByteArray_write64be :: ForeignFunc
ImmutableArray_read :: ForeignFunc
ImmutableByteArray_read8 :: ForeignFunc
ImmutableByteArray_read16be :: ForeignFunc
ImmutableByteArray_read24be :: ForeignFunc
ImmutableByteArray_read32be :: ForeignFunc
ImmutableByteArray_read40be :: ForeignFunc
ImmutableByteArray_read64be :: ForeignFunc
MutableByteArray_freeze_force :: ForeignFunc
MutableArray_freeze_force :: ForeignFunc
MutableByteArray_freeze :: ForeignFunc
MutableArray_freeze :: ForeignFunc
MutableByteArray_length :: ForeignFunc
ImmutableByteArray_length :: ForeignFunc
IO_array :: ForeignFunc
IO_arrayOf :: ForeignFunc
IO_bytearray :: ForeignFunc
IO_bytearrayOf :: ForeignFunc
Scope_array :: ForeignFunc
Scope_arrayOf :: ForeignFunc
Scope_bytearray :: ForeignFunc
Scope_bytearrayOf :: ForeignFunc
Text_patterns_literal :: ForeignFunc
Text_patterns_digit :: ForeignFunc
Text_patterns_letter :: ForeignFunc
Text_patterns_space :: ForeignFunc
Text_patterns_punctuation :: ForeignFunc
Text_patterns_anyChar :: ForeignFunc
Text_patterns_eof :: ForeignFunc
Text_patterns_charRange :: ForeignFunc
Text_patterns_notCharRange :: ForeignFunc
Text_patterns_charIn :: ForeignFunc
Text_patterns_notCharIn :: ForeignFunc
Pattern_many :: ForeignFunc
Pattern_many_corrected :: ForeignFunc
Pattern_capture :: ForeignFunc
Pattern_captureAs :: ForeignFunc
Pattern_join :: ForeignFunc
Pattern_or :: ForeignFunc
Pattern_replicate :: ForeignFunc
Pattern_run :: ForeignFunc
Pattern_isMatch :: ForeignFunc
Char_Class_any :: ForeignFunc
Char_Class_not :: ForeignFunc
Char_Class_and :: ForeignFunc
Char_Class_or :: ForeignFunc
Char_Class_range :: ForeignFunc
Char_Class_anyOf :: ForeignFunc
Char_Class_alphanumeric :: ForeignFunc
Char_Class_upper :: ForeignFunc
Char_Class_lower :: ForeignFunc
Char_Class_whitespace :: ForeignFunc
Char_Class_control :: ForeignFunc
Char_Class_printable :: ForeignFunc
Char_Class_mark :: ForeignFunc
Char_Class_number :: ForeignFunc
Char_Class_punctuation :: ForeignFunc
Char_Class_symbol :: ForeignFunc
Char_Class_separator :: ForeignFunc
Char_Class_letter :: ForeignFunc
Char_Class_is :: ForeignFunc
Text_patterns_char :: ForeignFunc
foreignFuncBuiltinName :: ForeignFunc -> Text
instance GHC.Enum.Bounded Unison.Runtime.Foreign.Function.Type.ForeignFunc
instance GHC.Enum.Enum Unison.Runtime.Foreign.Function.Type.ForeignFunc
instance GHC.Classes.Ord Unison.Runtime.Foreign.Function.Type.ForeignFunc
instance GHC.Classes.Eq Unison.Runtime.Foreign.Function.Type.ForeignFunc
instance GHC.Show.Show Unison.Runtime.Foreign.Function.Type.ForeignFunc

module Unison.Runtime.IOSource
debug :: Bool
parsingEnv :: ParsingEnv Identity
typecheckingEnv :: Env Symbol Ann
parsedFile :: UnisonFile Symbol Ann
typecheckedFile :: TypecheckedUnisonFile Symbol Ann
typecheckedFile' :: TypecheckedUnisonFile Symbol Ann
typecheckedFileTerms :: Map Symbol Reference
termNamed :: String -> Reference
codeLookup :: CodeLookup Symbol Identity Ann
codeLookupM :: Applicative m => CodeLookup Symbol m Ann
typeNamedId :: String -> Id
typeNamed :: String -> Reference
abilityNamedId :: String -> Id
eitherReference :: Reference
optionReference :: Reference
isTestReference :: Reference
isPropagatedReference :: Reference
isTest :: (Reference, Reference)
isIOTest :: (Reference, Reference)
isPropagatedValue :: Reference
eitherLeftId :: ConstructorId
eitherRightId :: ConstructorId
someId :: ConstructorId
noneId :: ConstructorId
authorRef :: Reference
guidRef :: Reference
copyrightHolderRef :: Reference
doc2Ref :: Reference
doc2SpecialFormRef :: Reference
doc2TermRef :: Reference
prettyRef :: Reference
prettyAnnotatedRef :: Reference
ansiColorRef :: Reference
consoleTextRef :: Reference
pattern Doc2Ref :: Reference
doc2WordId :: ConstructorId
doc2CodeId :: ConstructorId
doc2CodeBlockId :: ConstructorId
doc2BoldId :: ConstructorId
doc2ItalicId :: ConstructorId
doc2StrikethroughId :: ConstructorId
doc2StyleId :: ConstructorId
doc2AnchorId :: ConstructorId
doc2BlockquoteId :: ConstructorId
doc2BlanklineId :: ConstructorId
doc2LinebreakId :: ConstructorId
doc2SectionBreakId :: ConstructorId
doc2TooltipId :: ConstructorId
doc2AsideId :: ConstructorId
doc2CalloutId :: ConstructorId
doc2TableId :: ConstructorId
doc2FoldedId :: ConstructorId
doc2ParagraphId :: ConstructorId
doc2BulletedListId :: ConstructorId
doc2NumberedListId :: ConstructorId
doc2SectionId :: ConstructorId
doc2NamedLinkId :: ConstructorId
doc2ImageId :: ConstructorId
doc2SpecialId :: ConstructorId
doc2JoinId :: ConstructorId
doc2UntitledSectionId :: ConstructorId
doc2ColumnId :: ConstructorId
doc2GroupId :: ConstructorId
doc2MediaSourceRef :: Reference
pattern Doc2MediaSourceRef :: Reference
doc2VideoRef :: Reference
pattern Doc2VideoRef :: Reference
doc2FrontMatterRef :: Reference
pattern Doc2FrontMatterRef :: Reference
doc2LaTeXInlineRef :: Reference
pattern Doc2LaTeXInlineRef :: Reference
doc2SvgRef :: Reference
pattern Doc2SvgRef :: Reference
pattern Doc2Word :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Code :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2CodeBlock :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Bold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Italic :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Strikethrough :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Style :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Anchor :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Blockquote :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Blankline :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Linebreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SectionBreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Tooltip :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Aside :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Callout :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Table :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Folded :: Bool -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Paragraph :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2BulletedList :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2NumberedList :: Word64 -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Section :: Term2 typeVar typeAnn patternAnn v a -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2NamedLink :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Image :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Special :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Join :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2UntitledSection :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Column :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Group :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormRef :: Reference
doc2SpecialFormSourceId :: ConstructorId
doc2SpecialFormFoldedSourceId :: ConstructorId
doc2SpecialFormExampleId :: ConstructorId
doc2SpecialFormExampleBlockId :: ConstructorId
doc2SpecialFormLinkId :: ConstructorId
doc2SpecialFormSignatureId :: ConstructorId
doc2SpecialFormSignatureInlineId :: ConstructorId
doc2SpecialFormEvalId :: ConstructorId
doc2SpecialFormEvalInlineId :: ConstructorId
doc2SpecialFormEmbedId :: ConstructorId
doc2SpecialFormEmbedInlineId :: ConstructorId
pattern Doc2SpecialFormSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormFoldedSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormExample :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormExampleBlock :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormLink :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignature :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignatureInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEval :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEvalInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbed :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2MediaSource :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormEmbedVideo :: [Term (F typeVar typeAnn patternAnn) v a] -> [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedFrontMatter :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedLaTeXInline :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedSvg :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Example :: forall {vt} {at} {ap} {v} {a}. [v] -> Term2 vt at ap v a -> Term (F vt at ap) v a
pattern Doc2Term :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2TermRef :: Reference
pattern PrettyAnnotatedRef :: Reference
prettyEmptyId :: ConstructorId
prettyGroupId :: ConstructorId
prettyLitId :: ConstructorId
prettyWrapId :: ConstructorId
prettyOrElseId :: ConstructorId
prettyIndentId :: ConstructorId
prettyAppendId :: ConstructorId
prettyTableId :: ConstructorId
pattern PrettyEmpty :: Term (F typeVar typeAnn patternAnn) v a
pattern PrettyGroup :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyLit :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyWrap :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyIndent :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyOrElse :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyTable :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyAppend :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyRef :: Reference
prettyGetRef :: Reference
doc2FormatConsoleRef :: Reference
pattern AnsiColorRef :: Reference
ansiColorBlackId :: ConstructorId
pattern AnsiColorBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextRef :: Reference
consoleTextPlainId :: ConstructorId
consoleTextForegroundId :: ConstructorId
consoleTextBackgroundId :: ConstructorId
consoleTextBoldId :: ConstructorId
consoleTextUnderlineId :: ConstructorId
consoleTextInvertId :: ConstructorId
pattern ConsoleTextPlain :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextForeground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBackground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextUnderline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextInvert :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
iarrayFromListRef :: Reference
ibarrayFromBytesRef :: Reference
constructorNamed :: Reference -> Text -> ConstructorId
constructorName :: Reference -> ConstructorId -> Text
sourceString :: String
source :: Text
type Note = Note Symbol Ann
type TFile = TypecheckedUnisonFile Symbol Ann
type SynthResult = Result (Seq Note) (Either (UnisonFile Symbol Ann) TFile)
type EitherResult = Either String TFile
showNotes :: Foldable f => String -> Env -> f Note -> String
ppEnv :: PrettyPrintEnv


-- | Execute a computation of type '{IO} () that has been previously added
--   to the codebase, without setting up an interactive environment.
--   
--   This allows one to run standalone applications implemented in the
--   Unison language.
module Unison.Codebase.Execute
execute :: Codebase IO Symbol Ann -> Runtime Symbol -> ProjectPathNames -> IO (Either Error ())
codebaseToCodeLookup :: MonadIO m => Codebase m Symbol Ann -> CodeLookup Symbol m Ann

module Unison.Runtime.SparseVector
data SparseVector bits a
SparseVector :: !bits -> !Vector a -> SparseVector bits a
[$sel:indices:SparseVector] :: SparseVector bits a -> !bits
[$sel:elements:SparseVector] :: SparseVector bits a -> !Vector a
map :: (Unbox a, Unbox b) => (a -> b) -> SparseVector bits a -> SparseVector bits b
mask :: forall a bits. (Unbox a, FiniteBits bits) => bits -> SparseVector bits a -> SparseVector bits a
zipWith :: (Unbox a, Unbox b, Unbox c, FiniteBits bits) => (a -> b -> c) -> SparseVector bits a -> SparseVector bits b -> SparseVector bits c
_1 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits a
_2 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits b
unzip :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> (SparseVector bits a, SparseVector bits b)
choose :: (FiniteBits bits, Unbox a) => bits -> SparseVector bits a -> SparseVector bits a -> SparseVector bits a
merge :: forall a bits. (FiniteBits bits, Unbox a) => SparseVector bits a -> SparseVector bits a -> SparseVector bits a
eq :: a -> a -> Bool

module Unison.Runtime.TypeTags
class Tag t
rawTag :: Tag t => t -> Word64
newtype RTag
RTag :: Word64 -> RTag
newtype CTag
CTag :: Word16 -> CTag

-- | A combined tag, which is a packed representation of an RTag and a CTag
newtype PackedTag
PackedTag :: Word64 -> PackedTag
packTags :: RTag -> CTag -> PackedTag
unpackTags :: PackedTag -> (RTag, CTag)
maskTags :: PackedTag -> Word64
anyTag :: PackedTag
floatTag :: PackedTag
natTag :: PackedTag
intTag :: PackedTag
charTag :: PackedTag
unitTag :: PackedTag
leftTag :: PackedTag
rightTag :: PackedTag
noneTag :: PackedTag
someTag :: PackedTag
falseTag :: PackedTag
trueTag :: PackedTag
pairTag :: PackedTag
failureTag :: PackedTag
noBufTag :: PackedTag
lineBufTag :: PackedTag
blockBufTag :: PackedTag
sizedBlockBufTag :: PackedTag
readModeTag :: PackedTag
writeModeTag :: PackedTag
appendModeTag :: PackedTag
readWriteModeTag :: PackedTag
seekAbsoluteTag :: PackedTag
seekRelativeTag :: PackedTag
seekEndTag :: PackedTag
exceptionTag :: Word64
exceptionRaiseTag :: PackedTag
stdInTag :: PackedTag
stdOutTag :: PackedTag
stdErrTag :: PackedTag

-- | A tag we use to represent the <a>pure</a> effect case.
pureEffectTag :: PackedTag
seqViewElemTag :: PackedTag
seqViewEmptyTag :: PackedTag
instance GHC.Show.Show Unison.Runtime.TypeTags.CompileExn
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.TypeTags.RTag
instance GHC.Read.Read Unison.Runtime.TypeTags.RTag
instance GHC.Show.Show Unison.Runtime.TypeTags.RTag
instance GHC.Classes.Ord Unison.Runtime.TypeTags.RTag
instance GHC.Classes.Eq Unison.Runtime.TypeTags.RTag
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.TypeTags.CTag
instance GHC.Read.Read Unison.Runtime.TypeTags.CTag
instance GHC.Show.Show Unison.Runtime.TypeTags.CTag
instance GHC.Classes.Ord Unison.Runtime.TypeTags.CTag
instance GHC.Classes.Eq Unison.Runtime.TypeTags.CTag
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.TypeTags.PackedTag
instance GHC.Read.Read Unison.Runtime.TypeTags.PackedTag
instance GHC.Show.Show Unison.Runtime.TypeTags.PackedTag
instance GHC.Classes.Ord Unison.Runtime.TypeTags.PackedTag
instance GHC.Classes.Eq Unison.Runtime.TypeTags.PackedTag
instance Unison.Runtime.TypeTags.Tag Unison.Runtime.TypeTags.RTag
instance Unison.Runtime.TypeTags.Tag Unison.Runtime.TypeTags.CTag
instance GHC.Enum.Enum Unison.Runtime.TypeTags.CTag
instance GHC.Num.Num Unison.Runtime.TypeTags.CTag
instance GHC.Enum.Enum Unison.Runtime.TypeTags.RTag
instance GHC.Num.Num Unison.Runtime.TypeTags.RTag
instance GHC.Exception.Type.Exception Unison.Runtime.TypeTags.CompileExn

module Unison.Runtime.ANF
minimizeCyclesOrCrash :: Var v => Term v a -> Term v a
pattern TVar :: Var v => v -> Term ANormalF v
pattern TLit :: Var v => Lit -> Term ANormalF v
pattern TBLit :: Var v => Lit -> Term ANormalF v
pattern TApp :: Var v => Func v -> [v] -> Term ANormalF v
pattern TApv :: Var v => v -> [v] -> Term ANormalF v
pattern TCom :: Var v => Reference -> [v] -> Term ANormalF v
pattern TCon :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern UFalse :: Var v => Term ANormalF v
pattern UTrue :: Var v => Term ANormalF v
pattern TKon :: Var v => v -> [v] -> Term ANormalF v
pattern TReq :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern TPrm :: Var v => POp -> [v] -> Term ANormalF v
pattern TFOp :: Var v => ForeignFunc -> [v] -> Term ANormalF v
pattern THnd :: Var v => [Reference] -> v -> Term ANormalF v -> Term ANormalF v
pattern TLet :: Var v => Direction Word16 -> v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TLetD :: Var v => v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TFrc :: Var v => v -> Term ANormalF v
pattern TLets :: Var v => Direction Word16 -> [v] -> [Mem] -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TName :: Var v => v -> Either Reference v -> [v] -> Term ANormalF v -> Term ANormalF v
pattern TBind :: Var v => Cte v -> ANormal v -> ANormal v
pattern TBinds :: Var v => [Cte v] -> ANormal v -> ANormal v
pattern TShift :: Var v => Reference -> v -> Term ANormalF v -> Term ANormalF v
pattern TMatch :: Var v => v -> Branched (Term ANormalF v) -> Term ANormalF v
data CompileExn
CE :: CallStack -> Pretty ColorText -> CompileExn
internalBug :: HasCallStack => String -> a
data Mem
UN :: Mem
BX :: Mem
data Lit
I :: Int64 -> Lit
N :: Word64 -> Lit
F :: Double -> Lit
T :: Text -> Lit
C :: Char -> Lit
LM :: Referent -> Lit
LY :: Reference -> Lit

-- | Whether the evaluation of a given definition is cacheable or not. i.e.
--   it's a top-level pure value.
data Cacheability
Cacheable :: Cacheability
Uncacheable :: Cacheability
data Direction a
Indirect :: a -> Direction a
Direct :: Direction a
data SuperNormal v
Lambda :: [Mem] -> ANormal v -> SuperNormal v
[$sel:conventions:Lambda] :: SuperNormal v -> [Mem]
[$sel:bound:Lambda] :: SuperNormal v -> ANormal v
arity :: SuperNormal v -> Int
data SuperGroup v
Rec :: [(v, SuperNormal v)] -> SuperNormal v -> SuperGroup v
[$sel:group:Rec] :: SuperGroup v -> [(v, SuperNormal v)]
[$sel:entry:Rec] :: SuperGroup v -> SuperNormal v
arities :: SuperGroup v -> [Int]
data POp
ADDI :: POp
SUBI :: POp
MULI :: POp
DIVI :: POp
SGNI :: POp
NEGI :: POp
MODI :: POp
POWI :: POp
SHLI :: POp
SHRI :: POp
ANDI :: POp
IORI :: POp
XORI :: POp
COMI :: POp
INCI :: POp
DECI :: POp
LEQI :: POp
LESI :: POp
EQLI :: POp
NEQI :: POp
TRNC :: POp
ADDN :: POp
SUBN :: POp
DRPN :: POp
MULN :: POp
DIVN :: POp
MODN :: POp
TZRO :: POp
LZRO :: POp
POPC :: POp
POWN :: POp
SHLN :: POp
SHRN :: POp
ANDN :: POp
IORN :: POp
XORN :: POp
COMN :: POp
INCN :: POp
DECN :: POp
LEQN :: POp
LESN :: POp
EQLN :: POp
NEQN :: POp
ADDF :: POp
SUBF :: POp
MULF :: POp
DIVF :: POp
MINF :: POp
MAXF :: POp
LEQF :: POp
LESF :: POp
EQLF :: POp
NEQF :: POp
POWF :: POp
EXPF :: POp
SQRT :: POp
LOGF :: POp
LOGB :: POp
ABSF :: POp
CEIL :: POp
FLOR :: POp
TRNF :: POp
RNDF :: POp
COSF :: POp
ACOS :: POp
COSH :: POp
ACSH :: POp
SINF :: POp
ASIN :: POp
SINH :: POp
ASNH :: POp
TANF :: POp
ATAN :: POp
TANH :: POp
ATNH :: POp
ATN2 :: POp
CATT :: POp
TAKT :: POp
DRPT :: POp
SIZT :: POp
IXOT :: POp
UCNS :: POp
USNC :: POp
EQLT :: POp
LEQT :: POp
PAKT :: POp
UPKT :: POp
CATS :: POp
TAKS :: POp
DRPS :: POp
SIZS :: POp
CONS :: POp
SNOC :: POp
IDXS :: POp
BLDS :: POp
VWLS :: POp
VWRS :: POp
SPLL :: POp
SPLR :: POp
PAKB :: POp
UPKB :: POp
TAKB :: POp
DRPB :: POp
IXOB :: POp
IDXB :: POp
SIZB :: POp
FLTB :: POp
CATB :: POp
ITOF :: POp
NTOF :: POp
ITOT :: POp
NTOT :: POp
TTOI :: POp
TTON :: POp
TTOF :: POp
FTOT :: POp
CAST :: POp
FORK :: POp
EQLU :: POp
CMPU :: POp
LEQU :: POp
LESU :: POp
EROR :: POp
MISS :: POp
CACH :: POp
LKUP :: POp
LOAD :: POp
CVLD :: POp
SDBX :: POp
VALU :: POp
TLTT :: POp
PRNT :: POp
INFO :: POp
TRCE :: POp
DBTX :: POp
ATOM :: POp
TFRC :: POp
SDBL :: POp
SDBV :: POp
REFN :: POp
REFR :: POp
REFW :: POp
RCAS :: POp
RRFC :: POp
TIKR :: POp
NOTB :: POp
ANDB :: POp
IORB :: POp
close :: (Var v, Monoid a) => Set v -> Term v a -> Term v a
saturate :: (Var v, Monoid a) => Map ConstructorReference Int -> Term v a -> Term v a
float :: Var v => Monoid a => Map v Reference -> Term v a -> (Term v a, Map Reference Reference, [(Reference, Term v a)], [(Reference, Term v a)])
floatGroup :: Var v => Monoid a => Map v Reference -> [(v, Term v a)] -> ([(v, Id)], [(Reference, Term v a)], [(Reference, Term v a)])
lamLift :: Var v => Monoid a => Map v Reference -> Term v a -> (Term v a, Map Reference Reference, [(Reference, Term v a)], [(Reference, Term v a)])
lamLiftGroup :: Var v => Monoid a => Map v Reference -> [(v, Term v a)] -> ([(v, Id)], [(Reference, Term v a)], [(Reference, Term v a)])
litRef :: Lit -> Reference
inlineAlias :: Var v => Monoid a => Term v a -> Term v a
addDefaultCases :: Var v => Monoid a => Text -> Term v a -> Term v a
data ANormalF v e
ALet :: Direction Word16 -> [Mem] -> e -> e -> ANormalF v e
AName :: Either Reference v -> [v] -> e -> ANormalF v e
ALit :: Lit -> ANormalF v e
ABLit :: Lit -> ANormalF v e
AMatch :: v -> Branched e -> ANormalF v e
AShift :: Reference -> e -> ANormalF v e
AHnd :: [Reference] -> v -> e -> ANormalF v e
AApp :: Func v -> [v] -> ANormalF v e
AFrc :: v -> ANormalF v e
AVar :: v -> ANormalF v e
pattern AApv :: v -> [v] -> ANormalF v e
pattern ACom :: Reference -> [v] -> ANormalF v e
pattern ACon :: Reference -> CTag -> [v] -> ANormalF v e
pattern AKon :: v -> [v] -> ANormalF v e
pattern AReq :: Reference -> CTag -> [v] -> ANormalF v e
pattern APrm :: POp -> [v] -> ANormalF v e
pattern AFOp :: ForeignFunc -> [v] -> ANormalF v e
type ANormal = Term ANormalF
data RTag
data CTag

-- | A combined tag, which is a packed representation of an RTag and a CTag
newtype PackedTag
PackedTag :: Word64 -> PackedTag
class Tag t
rawTag :: Tag t => t -> Word64
data GroupRef
GR :: Reference -> Word64 -> GroupRef
data Code
CodeRep :: SuperGroup Symbol -> Cacheability -> Code

-- | A list of either unboxed or boxed values. Each slot is one of unboxed
--   or boxed but not both.
type ValList = [Value]
data Value
Partial :: GroupRef -> ValList -> Value
Data :: Reference -> Word64 -> ValList -> Value
Cont :: ValList -> Cont -> Value
BLit :: BLit -> Value
data Cont
KE :: Cont
Mark :: Word64 -> [Reference] -> Map Reference Value -> Cont -> Cont
Push :: Word64 -> Word64 -> GroupRef -> Cont -> Cont
data BLit
Text :: Text -> BLit
List :: Seq Value -> BLit
TmLink :: Referent -> BLit
TyLink :: Reference -> BLit
Bytes :: Bytes -> BLit
Quote :: Value -> BLit
Code :: Code -> BLit
BArr :: ByteArray -> BLit
Arr :: Array Value -> BLit
Pos :: Word64 -> BLit
Neg :: Word64 -> BLit
Char :: Char -> BLit
Float :: Double -> BLit
packTags :: RTag -> CTag -> PackedTag
unpackTags :: PackedTag -> (RTag, CTag)
maskTags :: PackedTag -> Word64
type ANFM v = ReaderT (Set v) (State (Word64, Word16, [(v, SuperNormal v)]))
data Branched e
MatchIntegral :: EnumMap Word64 e -> Maybe e -> Branched e
MatchText :: Map Text e -> Maybe e -> Branched e
MatchRequest :: Map Reference (EnumMap CTag ([Mem], e)) -> e -> Branched e
MatchEmpty :: Branched e
MatchData :: Reference -> EnumMap CTag ([Mem], e) -> Maybe e -> Branched e
MatchSum :: EnumMap Word64 ([Mem], e) -> Branched e
MatchNumeric :: Reference -> EnumMap Word64 e -> Maybe e -> Branched e
pattern MatchDataCover :: Reference -> EnumMap CTag ([Mem], e) -> Branched e
data Func v
FVar :: v -> Func v
FComb :: !Reference -> Func v
FCont :: v -> Func v
FCon :: !Reference -> !CTag -> Func v
FReq :: !Reference -> !CTag -> Func v
FPrim :: Either POp ForeignFunc -> Func v
data SGEqv v
NumDefns :: SuperGroup v -> SuperGroup v -> SGEqv v
DefnConventions :: SuperNormal v -> SuperNormal v -> SGEqv v
Subterms :: ANormal v -> ANormal v -> SGEqv v
equivocate :: Var v => SuperGroup v -> SuperGroup v -> Either (SGEqv v) ()
superNormalize :: Var v => Term v a -> SuperGroup v
anfTerm :: Var v => Term v a -> ANFM v (DNormal v)
codeGroup :: Code -> SuperGroup Symbol
valueTermLinks :: Value -> [Reference]
valueLinks :: Monoid a => (Bool -> Reference -> a) -> Value -> a
groupTermLinks :: Var v => SuperGroup v -> [Reference]
buildInlineMap :: Var v => Map Reference (SuperGroup v) -> Map Reference (Int, ANormal v)
inline :: Var v => Map Reference (Int, ANormal v) -> SuperGroup v -> SuperGroup v
foldGroup :: Monoid m => (SuperGroup Symbol -> m) -> Code -> m
foldGroupLinks :: (Monoid r, Var v) => (Bool -> Reference -> r) -> SuperGroup v -> r
overGroup :: (SuperGroup Symbol -> SuperGroup Symbol) -> Code -> Code
overGroupLinks :: Var v => (Bool -> Reference -> Reference) -> SuperGroup v -> SuperGroup v
traverseGroup :: Applicative f => (SuperGroup Symbol -> f (SuperGroup Symbol)) -> Code -> f Code
traverseGroupLinks :: (Applicative f, Var v) => (Bool -> Reference -> f Reference) -> SuperGroup v -> f (SuperGroup v)
normalLinks :: (Applicative f, Var v) => (Bool -> Reference -> f Reference) -> SuperNormal v -> f (SuperNormal v)
prettyGroup :: Var v => String -> SuperGroup v -> ShowS
prettySuperNormal :: Var v => Int -> SuperNormal v -> ShowS
prettyANF :: Var v => Bool -> Int -> ANormal v -> ShowS
instance GHC.Show.Show Unison.Runtime.ANF.CompileExn
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.Prefix v x)
instance GHC.Enum.Enum Unison.Runtime.ANF.Mem
instance GHC.Show.Show Unison.Runtime.ANF.Mem
instance GHC.Classes.Ord Unison.Runtime.ANF.Mem
instance GHC.Classes.Eq Unison.Runtime.ANF.Mem
instance GHC.Show.Show Unison.Runtime.ANF.SeqEnd
instance GHC.Enum.Enum Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Ord Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Eq Unison.Runtime.ANF.SeqEnd
instance Data.Traversable.Traversable Unison.Runtime.ANF.Branched
instance Data.Foldable.Foldable Unison.Runtime.ANF.Branched
instance GHC.Base.Functor Unison.Runtime.ANF.Branched
instance GHC.Classes.Eq e => GHC.Classes.Eq (Unison.Runtime.ANF.Branched e)
instance GHC.Show.Show e => GHC.Show.Show (Unison.Runtime.ANF.Branched e)
instance GHC.Classes.Eq Unison.Runtime.ANF.Lit
instance GHC.Show.Show Unison.Runtime.ANF.Lit
instance GHC.Enum.Bounded Unison.Runtime.ANF.POp
instance GHC.Enum.Enum Unison.Runtime.ANF.POp
instance GHC.Classes.Ord Unison.Runtime.ANF.POp
instance GHC.Classes.Eq Unison.Runtime.ANF.POp
instance GHC.Show.Show Unison.Runtime.ANF.POp
instance Data.Traversable.Traversable Unison.Runtime.ANF.Func
instance Data.Foldable.Foldable Unison.Runtime.ANF.Func
instance GHC.Base.Functor Unison.Runtime.ANF.Func
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Runtime.ANF.Func v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.Func v)
instance Data.Traversable.Traversable Unison.Runtime.ANF.Direction
instance Data.Foldable.Foldable Unison.Runtime.ANF.Direction
instance GHC.Base.Functor Unison.Runtime.ANF.Direction
instance GHC.Show.Show a => GHC.Show.Show (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Runtime.ANF.Direction a)
instance Data.Traversable.Traversable (Unison.Runtime.ANF.ANormalF v)
instance Data.Foldable.Foldable (Unison.Runtime.ANF.ANormalF v)
instance GHC.Base.Functor (Unison.Runtime.ANF.ANormalF v)
instance (GHC.Classes.Eq e, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.Runtime.ANF.ANormalF v e)
instance (GHC.Show.Show e, GHC.Show.Show v) => GHC.Show.Show (Unison.Runtime.ANF.ANormalF v e)
instance (GHC.Show.Show s, GHC.Show.Show v) => GHC.Show.Show (Unison.Runtime.ANF.CTE v s)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Runtime.ANF.SuperNormal v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperNormal v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperGroup v)
instance GHC.Show.Show Unison.Runtime.ANF.Cacheability
instance GHC.Classes.Eq Unison.Runtime.ANF.Cacheability
instance GHC.Classes.Eq Unison.Runtime.ANF.GroupRef
instance GHC.Show.Show Unison.Runtime.ANF.GroupRef
instance GHC.Show.Show Unison.Runtime.ANF.Code
instance GHC.Classes.Eq Unison.Runtime.ANF.Cont
instance GHC.Show.Show Unison.Runtime.ANF.Cont
instance GHC.Classes.Eq Unison.Runtime.ANF.Value
instance GHC.Show.Show Unison.Runtime.ANF.Value
instance GHC.Classes.Eq Unison.Runtime.ANF.BLit
instance GHC.Show.Show Unison.Runtime.ANF.BLit
instance GHC.Classes.Eq Unison.Runtime.ANF.Code
instance Unison.Var.Var v => GHC.Classes.Eq (Unison.Runtime.ANF.SuperGroup v)
instance GHC.Base.Semigroup (Unison.Runtime.ANF.BranchAccum v)
instance GHC.Base.Monoid (Unison.Runtime.ANF.BranchAccum e)
instance Data.Bifunctor.Bifunctor Unison.Runtime.ANF.ANormalF
instance Data.Bifoldable.Bifoldable Unison.Runtime.ANF.ANormalF
instance Unison.ABT.Normalized.Align Unison.Runtime.ANF.ANormalF
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Runtime.ANF.Direction a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Unison.Runtime.ANF.Direction a)
instance GHC.Base.Functor (Unison.Runtime.ANF.Prefix v)
instance GHC.Classes.Ord v => GHC.Base.Applicative (Unison.Runtime.ANF.Prefix v)
instance GHC.Exception.Type.Exception Unison.Runtime.ANF.CompileExn

module Unison.Runtime.Pattern
type DataSpec = Map Reference (Either Cons Cons)
splitPatterns :: Var v => DataSpec -> Term v -> Term v
builtinDataSpec :: DataSpec
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternRow v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternMatrix v)
instance GHC.Show.Show Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Ord Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Eq Unison.Runtime.Pattern.SeqMatch
instance GHC.Base.Semigroup Unison.Runtime.Pattern.PType
instance GHC.Base.Monoid Unison.Runtime.Pattern.PType

module Unison.Runtime.MCode
data Args'
Arg1 :: !Int -> Args'
Arg2 :: !Int -> !Int -> Args'
ArgN :: {-# UNPACK #-} !PrimArray Int -> Args'
ArgR :: !Int -> !Int -> Args'
data Args
ZArgs :: Args
VArg1 :: !Int -> Args
VArg2 :: !Int -> !Int -> Args
VArgR :: !Int -> !Int -> Args
VArgN :: {-# UNPACK #-} !PrimArray Int -> Args
VArgV :: !Int -> Args
data RefNums
RN :: (Reference -> Word64) -> (Reference -> Word64) -> (Reference -> Maybe Int) -> RefNums
[$sel:dnum:RN] :: RefNums -> Reference -> Word64
[$sel:cnum:RN] :: RefNums -> Reference -> Word64
[$sel:anum:RN] :: RefNums -> Reference -> Maybe Int
data MLit
MI :: !Int -> MLit
MN :: !Word64 -> MLit
MC :: !Char -> MLit
MD :: !Double -> MLit
MT :: !Text -> MLit
MM :: !Referent -> MLit
MY :: !Reference -> MLit
data GInstr comb
Prim1 :: !Prim1 -> !Int -> GInstr comb
Prim2 :: !Prim2 -> !Int -> !Int -> GInstr comb
RefCAS :: !Int -> !Int -> !Int -> GInstr comb
ForeignCall :: !Bool -> !ForeignFunc -> !Args -> GInstr comb
SetDyn :: !Word64 -> !Int -> GInstr comb
Capture :: !Word64 -> GInstr comb
Name :: !GRef comb -> !Args -> GInstr comb
Info :: !String -> GInstr comb
Pack :: !Reference -> !PackedTag -> !Args -> GInstr comb
Lit :: !MLit -> GInstr comb
Print :: !Int -> GInstr comb
Reset :: !EnumSet Word64 -> GInstr comb
Fork :: !Int -> GInstr comb
Atomically :: !Int -> GInstr comb
Seq :: !Args -> GInstr comb
TryForce :: !Int -> GInstr comb
SandboxingFailure :: !Text -> GInstr comb
type Instr = GInstr CombIx
type RInstr val = GInstr (RComb val)
data GSection comb
App :: !Bool -> !GRef comb -> !Args -> GSection comb
Call :: !Bool -> !CombIx -> comb -> !Args -> GSection comb
Jump :: !Int -> !Args -> GSection comb
Match :: !Int -> !GBranch comb -> GSection comb
Yield :: !Args -> GSection comb
Ins :: !GInstr comb -> !GSection comb -> GSection comb
Let :: !GSection comb -> !CombIx -> !Int -> !GSection comb -> GSection comb
Die :: String -> GSection comb
Exit :: GSection comb
DMatch :: !Maybe Reference -> !Int -> !GBranch comb -> GSection comb
NMatch :: !Maybe Reference -> !Int -> !GBranch comb -> GSection comb
RMatch :: !Int -> !GSection comb -> !EnumMap Word64 (GBranch comb) -> GSection comb
pattern MatchT :: Int -> GSection comb -> Map Text (GSection comb) -> GSection comb
pattern MatchW :: Int -> GSection comb -> EnumMap Word64 (GSection comb) -> GSection comb
type RSection val = GSection (RComb val)
type Section = GSection CombIx
data GComb val comb
Comb :: {-# UNPACK #-} !GCombInfo comb -> GComb val comb
CachedVal :: !Word64 -> !val -> GComb val comb
pattern Lam :: Int -> Int -> GSection comb -> GComb val comb
data GCombInfo comb
LamI :: !Int -> !Int -> !GSection comb -> GCombInfo comb
type Comb = GComb Void CombIx

-- | The fixed point of a GComb where all references to a Comb are
--   themselves Combs.
newtype RComb val
RComb :: GComb val (RComb val) -> RComb val
[$sel:unRComb:RComb] :: RComb val -> GComb val (RComb val)
type RCombInfo val = GCombInfo (RComb val)

-- | Map of combinators, parameterized by comb reference type
type GCombs val comb = EnumMap Word64 (GComb val comb)
type RCombs val = GCombs val (RComb val)
data CombIx
CIx :: !Reference -> !Word64 -> !Word64 -> CombIx
data GRef comb
Stk :: !Int -> GRef comb
Env :: !CombIx -> comb -> GRef comb
Dyn :: !Word64 -> GRef comb
type RRef val = GRef (RComb val)

-- | A reference to a combinator, parameterized by comb
type Ref = GRef CombIx
data Prim1
DECI :: Prim1
DECN :: Prim1
INCI :: Prim1
INCN :: Prim1
NEGI :: Prim1
SGNI :: Prim1
LZRO :: Prim1
TZRO :: Prim1
COMN :: Prim1
COMI :: Prim1
POPC :: Prim1
ABSF :: Prim1
EXPF :: Prim1
LOGF :: Prim1
SQRT :: Prim1
COSF :: Prim1
ACOS :: Prim1
COSH :: Prim1
ACSH :: Prim1
SINF :: Prim1
ASIN :: Prim1
SINH :: Prim1
ASNH :: Prim1
TANF :: Prim1
ATAN :: Prim1
TANH :: Prim1
ATNH :: Prim1
ITOF :: Prim1
NTOF :: Prim1
CEIL :: Prim1
FLOR :: Prim1
TRNF :: Prim1
RNDF :: Prim1
TRNC :: Prim1
NOTB :: Prim1
SIZT :: Prim1
USNC :: Prim1
UCNS :: Prim1
ITOT :: Prim1
NTOT :: Prim1
FTOT :: Prim1
TTOI :: Prim1
TTON :: Prim1
TTOF :: Prim1
PAKT :: Prim1
UPKT :: Prim1
VWLS :: Prim1
VWRS :: Prim1
SIZS :: Prim1
PAKB :: Prim1
UPKB :: Prim1
SIZB :: Prim1
FLTB :: Prim1
MISS :: Prim1
CACH :: Prim1
LKUP :: Prim1
LOAD :: Prim1
CVLD :: Prim1
VALU :: Prim1
TLTT :: Prim1
DBTX :: Prim1
SDBL :: Prim1
REFN :: Prim1
REFR :: Prim1
RRFC :: Prim1
TIKR :: Prim1
data Prim2
ADDI :: Prim2
ADDN :: Prim2
SUBI :: Prim2
SUBN :: Prim2
MULI :: Prim2
MULN :: Prim2
DIVI :: Prim2
DIVN :: Prim2
MODI :: Prim2
MODN :: Prim2
SHLI :: Prim2
SHLN :: Prim2
SHRI :: Prim2
SHRN :: Prim2
POWI :: Prim2
POWN :: Prim2
EQLI :: Prim2
EQLN :: Prim2
NEQI :: Prim2
NEQN :: Prim2
LEQI :: Prim2
LEQN :: Prim2
LESI :: Prim2
LESN :: Prim2
ANDN :: Prim2
ANDI :: Prim2
IORN :: Prim2
IORI :: Prim2
XORN :: Prim2
XORI :: Prim2
EQLF :: Prim2
NEQF :: Prim2
LEQF :: Prim2
LESF :: Prim2
ADDF :: Prim2
SUBF :: Prim2
MULF :: Prim2
DIVF :: Prim2
ATN2 :: Prim2
POWF :: Prim2
LOGB :: Prim2
MAXF :: Prim2
MINF :: Prim2
CAST :: Prim2
DRPN :: Prim2
ANDB :: Prim2
IORB :: Prim2
EQLU :: Prim2
CMPU :: Prim2
LEQU :: Prim2
LESU :: Prim2
DRPT :: Prim2
CATT :: Prim2
TAKT :: Prim2
IXOT :: Prim2
EQLT :: Prim2
LEQT :: Prim2
LEST :: Prim2
DRPS :: Prim2
CATS :: Prim2
TAKS :: Prim2
CONS :: Prim2
SNOC :: Prim2
IDXS :: Prim2
SPLL :: Prim2
SPLR :: Prim2
TAKB :: Prim2
DRPB :: Prim2
IDXB :: Prim2
CATB :: Prim2
IXOB :: Prim2
THRO :: Prim2
TRCE :: Prim2
SDBX :: Prim2
SDBV :: Prim2
REFW :: Prim2
data GBranch comb
Test1 :: !Word64 -> !GSection comb -> !GSection comb -> GBranch comb
Test2 :: !Word64 -> !GSection comb -> !Word64 -> !GSection comb -> !GSection comb -> GBranch comb
TestW :: !GSection comb -> !EnumMap Word64 (GSection comb) -> GBranch comb
TestT :: !GSection comb -> !Map Text (GSection comb) -> GBranch comb
type Branch = GBranch CombIx
type RBranch val = GBranch (RComb val)
emitCombs :: Var v => RefNums -> Reference -> Word64 -> SuperGroup v -> EnumMap Word64 Comb
emitComb :: Var v => RefNums -> Reference -> Word64 -> RCtx v -> (Word64, SuperNormal v) -> EnumMap Word64 Comb

-- | lazily replace all references to combinators with the combinators
--   themselves, tying the knot recursively when necessary.
resolveCombs :: Maybe (EnumMap Word64 (RCombs val)) -> EnumMap Word64 (GCombs val CombIx) -> EnumMap Word64 (RCombs val)

-- | If running in a sandboxed environment, replace all restricted foreign
--   functions with an error.
sanitizeCombsOfForeignFuncs :: Bool -> Set ForeignFunc -> EnumMap Word64 (EnumMap Word64 (GComb Void CombIx)) -> EnumMap Word64 (EnumMap Word64 (GComb Void CombIx))
absurdCombs :: EnumMap Word64 (EnumMap Word64 (GComb Void cix)) -> EnumMap Word64 (GCombs any cix)
emptyRNs :: RefNums
argsToLists :: Args -> [Int]
countArgs :: Args -> Int
combRef :: CombIx -> Reference
combDeps :: GComb val comb -> [Word64]
combTypes :: GComb any comb -> [Word64]
prettyCombs :: Word64 -> EnumMap Word64 Comb -> ShowS
prettyComb :: (Show val, Show comb) => Word64 -> Word64 -> GComb val comb -> ShowS
instance GHC.Classes.Ord Unison.Runtime.MCode.Sandboxed
instance GHC.Classes.Eq Unison.Runtime.MCode.Sandboxed
instance GHC.Show.Show Unison.Runtime.MCode.Sandboxed
instance GHC.Show.Show Unison.Runtime.MCode.Args'
instance GHC.Classes.Ord Unison.Runtime.MCode.Args
instance GHC.Classes.Eq Unison.Runtime.MCode.Args
instance GHC.Show.Show Unison.Runtime.MCode.Args
instance GHC.Enum.Bounded Unison.Runtime.MCode.Prim1
instance GHC.Enum.Enum Unison.Runtime.MCode.Prim1
instance GHC.Classes.Ord Unison.Runtime.MCode.Prim1
instance GHC.Classes.Eq Unison.Runtime.MCode.Prim1
instance GHC.Show.Show Unison.Runtime.MCode.Prim1
instance GHC.Enum.Bounded Unison.Runtime.MCode.Prim2
instance GHC.Enum.Enum Unison.Runtime.MCode.Prim2
instance GHC.Classes.Ord Unison.Runtime.MCode.Prim2
instance GHC.Classes.Eq Unison.Runtime.MCode.Prim2
instance GHC.Show.Show Unison.Runtime.MCode.Prim2
instance GHC.Classes.Ord Unison.Runtime.MCode.MLit
instance GHC.Classes.Eq Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.CombIx
instance GHC.Classes.Ord Unison.Runtime.MCode.CombIx
instance GHC.Classes.Eq Unison.Runtime.MCode.CombIx
instance Data.Traversable.Traversable Unison.Runtime.MCode.GRef
instance Data.Foldable.Foldable Unison.Runtime.MCode.GRef
instance GHC.Base.Functor Unison.Runtime.MCode.GRef
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GRef comb)
instance Data.Traversable.Traversable Unison.Runtime.MCode.GInstr
instance Data.Foldable.Foldable Unison.Runtime.MCode.GInstr
instance GHC.Base.Functor Unison.Runtime.MCode.GInstr
instance GHC.Classes.Ord (Unison.Runtime.MCode.GInstr comb)
instance GHC.Classes.Eq (Unison.Runtime.MCode.GInstr comb)
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GInstr comb)
instance Data.Traversable.Traversable Unison.Runtime.MCode.GSection
instance Data.Foldable.Foldable Unison.Runtime.MCode.GSection
instance GHC.Base.Functor Unison.Runtime.MCode.GSection
instance GHC.Classes.Ord comb => GHC.Classes.Ord (Unison.Runtime.MCode.GSection comb)
instance GHC.Classes.Eq comb => GHC.Classes.Eq (Unison.Runtime.MCode.GSection comb)
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GSection comb)
instance Data.Traversable.Traversable Unison.Runtime.MCode.GBranch
instance Data.Foldable.Foldable Unison.Runtime.MCode.GBranch
instance GHC.Base.Functor Unison.Runtime.MCode.GBranch
instance GHC.Classes.Ord comb => GHC.Classes.Ord (Unison.Runtime.MCode.GBranch comb)
instance GHC.Classes.Eq comb => GHC.Classes.Eq (Unison.Runtime.MCode.GBranch comb)
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GBranch comb)
instance Data.Traversable.Traversable Unison.Runtime.MCode.GCombInfo
instance Data.Foldable.Foldable Unison.Runtime.MCode.GCombInfo
instance GHC.Base.Functor Unison.Runtime.MCode.GCombInfo
instance GHC.Classes.Ord comb => GHC.Classes.Ord (Unison.Runtime.MCode.GCombInfo comb)
instance GHC.Classes.Eq comb => GHC.Classes.Eq (Unison.Runtime.MCode.GCombInfo comb)
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GCombInfo comb)
instance Data.Traversable.Traversable (Unison.Runtime.MCode.GComb val)
instance Data.Foldable.Foldable (Unison.Runtime.MCode.GComb val)
instance GHC.Base.Functor (Unison.Runtime.MCode.GComb val)
instance (GHC.Classes.Ord comb, GHC.Classes.Ord val) => GHC.Classes.Ord (Unison.Runtime.MCode.GComb val comb)
instance (GHC.Classes.Eq comb, GHC.Classes.Eq val) => GHC.Classes.Eq (Unison.Runtime.MCode.GComb val comb)
instance (GHC.Show.Show comb, GHC.Show.Show val) => GHC.Show.Show (Unison.Runtime.MCode.GComb val comb)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.MCode.Ctx v)
instance GHC.Base.Functor Unison.Runtime.MCode.Counted
instance GHC.Base.Functor Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Counted
instance GHC.Show.Show (Unison.Runtime.MCode.RComb val)
instance Data.Bifunctor.Bifunctor Unison.Runtime.MCode.GComb
instance Data.Bifoldable.Bifoldable Unison.Runtime.MCode.GComb
instance Data.Bitraversable.Bitraversable Unison.Runtime.MCode.GComb
instance GHC.Classes.Eq (Unison.Runtime.MCode.GRef comb)
instance GHC.Classes.Ord (Unison.Runtime.MCode.GRef comb)

module Unison.Runtime.Foreign
data Foreign
[Wrap] :: Reference -> !e -> Foreign
data HashAlgorithm
[HashAlgorithm] :: HashAlgorithm a => Reference -> a -> HashAlgorithm
unwrapForeign :: Foreign -> a
maybeUnwrapForeign :: Reference -> Foreign -> Maybe a
wrapBuiltin :: forall f. BuiltinForeign f => f -> Foreign
maybeUnwrapBuiltin :: forall f. BuiltinForeign f => Foreign -> Maybe f
unwrapBuiltin :: BuiltinForeign f => Foreign -> f
class BuiltinForeign f
foreignName :: BuiltinForeign f => Tagged f String
foreignRef :: BuiltinForeign f => Tagged f Reference
newtype Tls
Tls :: Context -> Tls
data Failure a
Failure :: Reference -> Text -> a -> Failure a
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.Foreign.HashAlgorithm
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Text
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Bytes.Bytes
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.Handle.Types.Handle
instance Unison.Runtime.Foreign.BuiltinForeign System.Process.Common.ProcessHandle
instance Unison.Runtime.Foreign.BuiltinForeign U.Codebase.Reference.Reference
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Referent.Referent
instance Unison.Runtime.Foreign.BuiltinForeign Network.Socket.Types.Socket
instance Unison.Runtime.Foreign.BuiltinForeign Network.UDP.ListenSocket
instance Unison.Runtime.Foreign.BuiltinForeign Network.UDP.ClientSockAddr
instance Unison.Runtime.Foreign.BuiltinForeign Network.UDP.UDPSocket
instance Unison.Runtime.Foreign.BuiltinForeign GHC.Conc.Sync.ThreadId
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ClientParams
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ServerParams
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.SignedCertificate
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.PrivateKey.PrivKey
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.FilePath
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Context.Internal.Context
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.ANF.Code
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.ANF.Value
instance Unison.Runtime.Foreign.BuiltinForeign System.Clock.TimeSpec
instance Unison.Runtime.Foreign.BuiltinForeign (Data.Atomics.Internal.Ticket a)
instance Unison.Runtime.Foreign.BuiltinForeign (GHC.MVar.MVar a)
instance Unison.Runtime.Foreign.BuiltinForeign (GHC.Conc.Sync.TVar a)
instance Unison.Runtime.Foreign.BuiltinForeign (Unison.Util.RefPromise.Promise a)
instance Unison.Runtime.Foreign.BuiltinForeign (Data.Primitive.Array.MutableArray s e)
instance Unison.Runtime.Foreign.BuiltinForeign (Data.Primitive.Array.Array e)
instance Unison.Runtime.Foreign.BuiltinForeign (Data.Array.Byte.MutableByteArray s)
instance Unison.Runtime.Foreign.BuiltinForeign Data.Array.Byte.ByteArray
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Pattern.CPattern
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Pattern.CharPattern
instance GHC.Classes.Eq Unison.Runtime.Foreign.Foreign
instance GHC.Classes.Ord Unison.Runtime.Foreign.Foreign
instance GHC.Show.Show Unison.Runtime.Foreign.Foreign

module Unison.Runtime.Stack
data K
KE :: K
CB :: Callback -> K
Mark :: !Int -> !EnumSet Word64 -> !EnumMap Word64 Val -> !K -> K
Push :: !Int -> !Int -> !CombIx -> !Int -> !RSection Val -> !K -> K
data GClosure comb
GPAp :: !CombIx -> {-# UNPACK #-} !GCombInfo comb -> {-# UNPACK #-} !Seg -> GClosure comb
GEnum :: !Reference -> !PackedTag -> GClosure comb
GData1 :: !Reference -> !PackedTag -> !Val -> GClosure comb
GData2 :: !Reference -> !PackedTag -> !Val -> !Val -> GClosure comb
GDataG :: !Reference -> !PackedTag -> {-# UNPACK #-} !Seg -> GClosure comb
GCaptured :: !K -> !Int -> {-# UNPACK #-} !Seg -> GClosure comb
GForeign :: !Foreign -> GClosure comb
GUnboxedTypeTag :: !UnboxedTypeTag -> GClosure comb
GBlackHole :: GClosure comb
newtype Closure
Closure :: GClosure (RComb Val) -> Closure
[$sel:unClosure:Closure] :: Closure -> GClosure (RComb Val)
pattern DataC :: Reference -> PackedTag -> SegList -> Closure
pattern PApV :: CombIx -> RCombInfo Val -> SegList -> Closure
pattern CapV :: K -> Int -> SegList -> Closure
pattern PAp :: CombIx -> GCombInfo (RComb Val) -> Seg -> Closure
pattern Enum :: Reference -> PackedTag -> Closure
pattern Data1 :: Reference -> PackedTag -> Val -> Closure
pattern Data2 :: Reference -> PackedTag -> Val -> Val -> Closure
pattern DataG :: Reference -> PackedTag -> Seg -> Closure
pattern Captured :: K -> Int -> Seg -> Closure
pattern Foreign :: Foreign -> Closure
pattern BlackHole :: Closure
pattern UnboxedTypeTag :: UnboxedTypeTag -> Closure
closureTag :: Closure -> PackedTag
unitClosure :: Closure
data UnboxedTypeTag
CharTag :: UnboxedTypeTag
FloatTag :: UnboxedTypeTag
IntTag :: UnboxedTypeTag
NatTag :: UnboxedTypeTag
unboxedTypeTagToInt :: UnboxedTypeTag -> Int
unboxedTypeTagFromInt :: HasCallStack => Int -> UnboxedTypeTag
type IxClosure = GClosure CombIx
newtype Callback
Hook :: (XStack -> IO ()) -> Callback
data Augment
I :: Augment
K :: Augment
C :: Augment
data Dump
A :: Dump
F :: Int -> Int -> Dump
S :: Dump
data Stack
Stack :: !Int -> !Int -> !Int -> {-# UNPACK #-} !MutableByteArray (PrimState IO) -> {-# UNPACK #-} !MutableArray (PrimState IO) Closure -> Stack
[$sel:ap:Stack] :: Stack -> !Int
[$sel:fp:Stack] :: Stack -> !Int
[$sel:sp:Stack] :: Stack -> !Int
[$sel:ustk:Stack] :: Stack -> {-# UNPACK #-} !MutableByteArray (PrimState IO)
[$sel:bstk:Stack] :: Stack -> {-# UNPACK #-} !MutableArray (PrimState IO) Closure
type XStack = (# Int#, Int#, Int#, MutableByteArray# (PrimState IO), MutableArray# (PrimState IO) Closure #)
pattern XStack :: Int# -> Int# -> Int# -> MutableByteArray# RealWorld -> MutableArray# RealWorld Closure -> Stack
packXStack :: XStack -> Stack
unpackXStack :: Stack -> XStack
xStackIOToIO :: IOXStack -> IO Stack
stackIOToIOX :: IO Stack -> IOXStack
estackIOToIOX :: IO (Bool, Stack) -> IOEXStack
exStackIOToIO :: IOEXStack -> IO (Bool, Stack)
type IOXStack = State# RealWorld -> (# State# RealWorld, XStack #)
type IOEXStack = State# RealWorld -> (# State# RealWorld, Bool, XStack #)
($sel:apX:XStack) :: Stack -> Int#
($sel:fpX:XStack) :: Stack -> Int#
($sel:spX:XStack) :: Stack -> Int#
($sel:ustkX:XStack) :: Stack -> MutableByteArray# RealWorld
($sel:bstkX:XStack) :: Stack -> MutableArray# RealWorld Closure
type Off = Int
type SZ = Int
type FP = Int
type Seg = (USeg, BSeg)
type USeg = ByteArray
type BSeg = Array Closure
type SegList = [Val]

-- | A runtime value, which is either a boxed or unboxed value, but we may
--   not know which.
data Val
Val :: !UVal -> !BVal -> Val
[$sel:getUnboxedVal:Val] :: Val -> !UVal
[$sel:getBoxedVal:Val] :: Val -> !BVal
pattern CharVal :: Char -> Val
pattern NatVal :: Word64 -> Val
pattern DoubleVal :: Double -> Val
pattern IntVal :: Int -> Val
pattern BoolVal :: Bool -> Val
pattern UnboxedVal :: Int -> UnboxedTypeTag -> Val

-- | Matches a Val which is known to be boxed, and returns the closure
--   portion.
pattern BoxedVal :: Closure -> Val

-- | A nulled out value you can use when filling empty arrays, etc.
emptyVal :: Val
falseVal :: Val
trueVal :: Val

-- | Lift a boxed val into an Val
boxedVal :: BVal -> Val

-- | Implementation for Unison sequences.
type USeq = Seq Val
traceK :: Reference -> K -> [(Reference, Int)]
frameDataSize :: K -> Int
data RuntimePanic
Panic :: String -> Maybe Val -> RuntimePanic
marshalToForeign :: HasCallStack => Closure -> Foreign
marshalUnwrapForeignIO :: HasCallStack => Closure -> IO a
unull :: USeg
bnull :: BSeg
nullSeg :: Seg
peekD :: Stack -> IO Double
peekOffD :: Stack -> Int -> IO Double
peekC :: Stack -> IO Char
peekOffC :: Stack -> Int -> IO Char
poke :: DebugCallStack => Stack -> Val -> IO ()
pokeD :: Stack -> Double -> IO ()
pokeOffD :: Stack -> Int -> Double -> IO ()
pokeC :: Stack -> Char -> IO ()
pokeOffC :: Stack -> Int -> Char -> IO ()
pokeBool :: DebugCallStack => Stack -> Bool -> IO ()

-- | Store an unboxed tag to later match on. Often used to indicate the
--   constructor of a data type that's been unpacked onto the stack, or
--   some tag we're about to branch on.
pokeTag :: DebugCallStack => Stack -> Int -> IO ()
peekTag :: DebugCallStack => Stack -> IO Int
peekTagOff :: DebugCallStack => Stack -> Off -> IO Int
peekI :: DebugCallStack => Stack -> IO Int
peekOffI :: DebugCallStack => Stack -> Off -> IO Int
peekN :: Stack -> IO Word64
peekOffN :: Stack -> Int -> IO Word64
pokeN :: Stack -> Word64 -> IO ()
pokeOffN :: Stack -> Int -> Word64 -> IO ()

-- | Note: This is for poking an unboxed value that has the UNISON type
--   <tt>int</tt>, not just any unboxed data.
pokeI :: Stack -> Int -> IO ()
pokeOffI :: Stack -> Int -> Int -> IO ()
pokeByte :: Stack -> Word8 -> IO ()
peekBi :: BuiltinForeign b => Stack -> IO b
peekOffBi :: BuiltinForeign b => Stack -> Int -> IO b
pokeBi :: BuiltinForeign b => Stack -> b -> IO ()
pokeOffBi :: BuiltinForeign b => Stack -> Int -> b -> IO ()
peekBool :: Stack -> IO Bool
peekOffBool :: Stack -> Int -> IO Bool
peekOffS :: Stack -> Int -> IO USeq
pokeS :: Stack -> USeq -> IO ()
pokeOffS :: Stack -> Int -> USeq -> IO ()
frameView :: Stack -> IO ()
scount :: Seg -> Int
closureTermRefs :: Monoid m => (Reference -> m) -> Closure -> m
dumpAP :: Int -> Int -> Int -> Dump -> Int
dumpFP :: Int -> Int -> Dump -> Int
alloc :: IO Stack
peek :: DebugCallStack => Stack -> IO Val
upeek :: DebugCallStack => Stack -> IO UVal
bpeek :: DebugCallStack => Stack -> IO BVal
peekOff :: DebugCallStack => Stack -> Off -> IO Val
upeekOff :: DebugCallStack => Stack -> Off -> IO UVal
bpeekOff :: DebugCallStack => Stack -> Off -> IO BVal

-- | Store a boxed value. We don't bother nulling out the unboxed stack,
--   it's extra work and there's nothing to garbage collect.
bpoke :: DebugCallStack => Stack -> BVal -> IO ()
bpokeOff :: DebugCallStack => Stack -> Off -> BVal -> IO ()
pokeOff :: DebugCallStack => Stack -> Off -> Val -> IO ()
upokeT :: DebugCallStack => Stack -> UVal -> BVal -> IO ()
upokeOffT :: DebugCallStack => Stack -> Off -> UVal -> BVal -> IO ()

-- | Sometimes we get back an int from a foreign call which we want to use
--   as a Nat. If we know it's positive and smaller than 2^63 then we can
--   safely store the Int directly as a Nat without checks.
unsafePokeIasN :: DebugCallStack => Stack -> Int -> IO ()
bump :: Stack -> IO Stack
bumpn :: Stack -> SZ -> IO Stack

-- | Eats up arguments
grab :: Stack -> SZ -> IO (Seg, Stack)
ensure :: Stack -> SZ -> IO Stack
duplicate :: Stack -> IO Stack
discardFrame :: Stack -> IO Stack
saveFrame :: Stack -> IO (Stack, SZ, SZ)
saveArgs :: Stack -> IO (Stack, SZ)
restoreFrame :: Stack -> SZ -> SZ -> IO Stack
prepareArgs :: Stack -> Args' -> IO Stack
acceptArgs :: Stack -> Int -> IO Stack
frameArgs :: Stack -> IO Stack
augSeg :: Augment -> Stack -> Seg -> Maybe Args' -> IO Seg
dumpSeg :: Stack -> Seg -> Dump -> IO Stack
adjustArgs :: Stack -> SZ -> IO Stack
fsize :: Stack -> SZ
asize :: Stack -> SZ

-- | Converts a list of integers representing an unboxed segment back into
--   the appropriate segment. Segments are stored backwards in the runtime,
--   so this reverses the list.
useg :: [Int] -> USeg

-- | Converts a list of closures back to a boxed segment. Segments are
--   stored backwards, so this reverses the contents.
bseg :: [Closure] -> BSeg
natTypeTag :: Closure
intTypeTag :: Closure
charTypeTag :: Closure
floatTypeTag :: Closure
hasNoAllocations :: Name -> Obligation
instance GHC.Classes.Ord Unison.Runtime.Stack.UnboxedTypeTag
instance GHC.Classes.Eq Unison.Runtime.Stack.UnboxedTypeTag
instance GHC.Show.Show Unison.Runtime.Stack.UnboxedTypeTag
instance Data.Traversable.Traversable Unison.Runtime.Stack.GClosure
instance Data.Foldable.Foldable Unison.Runtime.Stack.GClosure
instance GHC.Base.Functor Unison.Runtime.Stack.GClosure
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.Stack.GClosure comb)
instance GHC.Show.Show Unison.Runtime.Stack.Val
instance GHC.Show.Show Unison.Runtime.Stack.Closure
instance GHC.Show.Show Unison.Runtime.Stack.RuntimePanic
instance GHC.Show.Show Unison.Runtime.Stack.Stack
instance GHC.Exception.Type.Exception Unison.Runtime.Stack.RuntimePanic
instance GHC.Classes.Eq Unison.Runtime.Stack.Callback
instance GHC.Classes.Ord Unison.Runtime.Stack.Callback
instance Unison.Runtime.Foreign.BuiltinForeign (GHC.IORef.IORef Unison.Runtime.Stack.Val)
instance GHC.Show.Show Unison.Runtime.Stack.K

module Unison.Runtime.Exception
data RuntimeExn
PE :: CallStack -> Pretty ColorText -> RuntimeExn
BU :: [(Reference, Int)] -> Text -> Val -> RuntimeExn
die :: HasCallStack => String -> IO a
dieP :: HasCallStack => Pretty ColorText -> IO a
exn :: HasCallStack => String -> a
instance GHC.Show.Show Unison.Runtime.Exception.RuntimeExn
instance GHC.Exception.Type.Exception Unison.Runtime.Exception.RuntimeExn

module Unison.Runtime.Serialize
unknownTag :: MonadGet m => String -> Word8 -> m a
class Tag t
tag2word :: Tag t => t -> Word8
word2tag :: (Tag t, MonadGet m) => Word8 -> m t
putTag :: MonadPut m => Tag t => t -> m ()
getTag :: MonadGet m => Tag t => m t
putChar :: MonadPut m => Char -> m ()
getChar :: MonadGet m => m Char
putFloat :: MonadPut m => Double -> m ()
getFloat :: MonadGet m => m Double
putBool :: MonadPut m => Bool -> m ()
getBool :: MonadGet m => m Bool
putNat :: MonadPut m => Word64 -> m ()
getNat :: MonadGet m => m Word64
putInt :: MonadPut m => Int64 -> m ()
getInt :: MonadGet m => m Int64
putLength :: (MonadPut m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => n -> m ()
getLength :: (MonadGet m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => m n
putPositive :: (MonadPut m, Bits n, Bits (Unsigned n), Integral n, Integral (Unsigned n)) => n -> m ()
getPositive :: forall m n. (Bounded n, Integral n, MonadGet m) => m n
putFoldable :: (Foldable f, MonadPut m) => (a -> m ()) -> f a -> m ()
putMap :: MonadPut m => (a -> m ()) -> (b -> m ()) -> Map a b -> m ()
getList :: MonadGet m => m a -> m [a]
getMap :: (MonadGet m, Ord a) => m a -> m b -> m (Map a b)
putEnumMap :: MonadPut m => EnumKey k => (k -> m ()) -> (v -> m ()) -> EnumMap k v -> m ()
getEnumMap :: MonadGet m => EnumKey k => m k -> m v -> m (EnumMap k v)
putEnumSet :: MonadPut m => EnumKey k => (k -> m ()) -> EnumSet k -> m ()
getEnumSet :: MonadGet m => EnumKey k => m k -> m (EnumSet k)
putMaybe :: MonadPut m => Maybe a -> (a -> m ()) -> m ()
getMaybe :: MonadGet m => m a -> m (Maybe a)
putPair :: MonadPut m => (a -> m ()) -> (b -> m ()) -> (a, b) -> m ()
getPair :: MonadGet m => m a -> m b -> m (a, b)
getBytes :: MonadGet m => m Bytes
putBytes :: MonadPut m => Bytes -> m ()
getByteArray :: MonadGet m => m ByteArray
putByteArray :: MonadPut m => ByteArray -> m ()
getArray :: MonadGet m => m a -> m (Array a)
putArray :: MonadPut m => (a -> m ()) -> Array a -> m ()
getBlock :: MonadGet m => m Chunk
putBlock :: MonadPut m => Chunk -> m ()
putHash :: MonadPut m => Hash -> m ()
getHash :: MonadGet m => m Hash
putReferent :: MonadPut m => Referent -> m ()
getReferent :: MonadGet m => m Referent
getConstructorType :: MonadGet m => m ConstructorType
putConstructorType :: MonadPut m => ConstructorType -> m ()
putText :: MonadPut m => Text -> m ()
getText :: MonadGet m => m Text
putReference :: MonadPut m => Reference -> m ()
getReference :: MonadGet m => m Reference
putConstructorReference :: MonadPut m => ConstructorReference -> m ()
getConstructorReference :: MonadGet m => m ConstructorReference
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Prim1
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Prim2

module Unison.Runtime.MCode.Serialize
putComb :: MonadPut m => (clos -> m ()) -> GComb clos comb -> m ()
getComb :: MonadGet m => m (GComb Void CombIx)
putCombIx :: MonadPut m => CombIx -> m ()
getCombIx :: MonadGet m => m CombIx
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.BranchT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.MLitT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.RefT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.ArgsT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.InstrT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.SectionT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.CombT

module Unison.Runtime.Decompile
decompile :: forall v. Var v => (Reference -> Maybe Reference) -> (Word64 -> Word64 -> Maybe (Term v ())) -> Val -> DecompResult v
type DecompResult v = (Set DecompError, Term v ())
data DecompError
BadBool :: !Word64 -> DecompError
BadUnboxed :: !UnboxedTypeTag -> DecompError
BadForeign :: !Reference -> DecompError
BadData :: !Reference -> DecompError
BadPAp :: !Reference -> DecompError
UnkComb :: !Reference -> DecompError
UnkLocal :: !Reference -> !Word64 -> DecompError
Cont :: DecompError
Exn :: DecompError
renderDecompError :: DecompError -> Error
instance GHC.Classes.Ord Unison.Runtime.Decompile.DecompError
instance GHC.Classes.Eq Unison.Runtime.Decompile.DecompError

module Unison.Runtime.Debug
traceComb :: (Show clos, Show comb) => Bool -> Word64 -> GComb clos comb -> Bool
traceCombs :: Word64 -> Bool -> EnumMap Word64 Comb -> EnumMap Word64 Comb
tracePretty :: Var v => PrettyPrintEnv -> Bool -> Term v -> Term v
tracePrettyGroup :: Var v => Word64 -> Bool -> SuperGroup v -> SuperGroup v

module Unison.Runtime.Builtin
builtinTermNumbering :: Map Reference Word64
builtinTypeNumbering :: Map Reference Word64
builtinTermBackref :: EnumMap Word64 Reference
builtinTypeBackref :: EnumMap Word64 Reference
builtinArities :: Map Reference Int
builtinInlineInfo :: Map Reference (Int, ANormal Symbol)
numberedTermLookup :: EnumMap Word64 (SuperNormal Symbol)
data Sandbox
Tracked :: Sandbox
Untracked :: Sandbox
baseSandboxInfo :: Map Reference (Set Reference)
unitValue :: Val
natValue :: Word64 -> Val
builtinForeignNames :: Map ForeignFunc Text
sandboxedForeignFuncs :: Set ForeignFunc
instance GHC.Enum.Bounded Unison.Runtime.Builtin.Sandbox
instance GHC.Enum.Enum Unison.Runtime.Builtin.Sandbox
instance GHC.Read.Read Unison.Runtime.Builtin.Sandbox
instance GHC.Show.Show Unison.Runtime.Builtin.Sandbox
instance GHC.Classes.Ord Unison.Runtime.Builtin.Sandbox
instance GHC.Classes.Eq Unison.Runtime.Builtin.Sandbox
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v, v, v, v)

module Unison.Runtime.Machine.Types

-- | A ref storing every currently active thread. This is helpful for
--   cleaning up orphaned threads when the main process completes.
--   
--   We track threads when running in a host process like UCM, otherwise,
--   in one-off environments <a>Nothing</a> is used and we don't bother
--   tracking forked threads since they'll be cleaned up automatically on
--   process termination.
type ActiveThreads = Maybe (IORef (Set ThreadId))
type Tag = Word64
type DEnv = EnumMap Word64 Val
type MCombs = RCombs Val
type Combs = GCombs Void CombIx
type MSection = RSection Val
type MBranch = RBranch Val
type MInstr = RInstr Val
type MComb = RComb Val
type MRef = RRef Val
data Tracer
NoTrace :: Tracer
MsgTrace :: String -> String -> String -> Tracer
SimpleTrace :: String -> Tracer
refLookup :: String -> Map Reference Word64 -> Reference -> Word64
die :: HasCallStack => String -> IO a
data CCache
CCache :: Bool -> (Bool -> Val -> Tracer) -> TVar (EnumMap Word64 Combs) -> TVar (EnumMap Word64 MCombs) -> TVar (EnumMap Word64 Reference) -> TVar (EnumSet Word64) -> TVar (EnumMap Word64 Reference) -> TVar Word64 -> TVar Word64 -> TVar (Map Reference (SuperGroup Symbol)) -> TVar (Map Reference Word64) -> TVar (Map Reference Word64) -> TVar (Map Reference (Set Reference)) -> CCache
[$sel:sandboxed:CCache] :: CCache -> Bool
[$sel:tracer:CCache] :: CCache -> Bool -> Val -> Tracer
[$sel:srcCombs:CCache] :: CCache -> TVar (EnumMap Word64 Combs)
[$sel:combs:CCache] :: CCache -> TVar (EnumMap Word64 MCombs)
[$sel:combRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:cacheableCombs:CCache] :: CCache -> TVar (EnumSet Word64)
[$sel:tagRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:freshTm:CCache] :: CCache -> TVar Word64
[$sel:freshTy:CCache] :: CCache -> TVar Word64
[$sel:intermed:CCache] :: CCache -> TVar (Map Reference (SuperGroup Symbol))
[$sel:refTm:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:refTy:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:sandbox:CCache] :: CCache -> TVar (Map Reference (Set Reference))
refNumsTm :: CCache -> IO (Map Reference Word64)
refNumsTy :: CCache -> IO (Map Reference Word64)
refNumTm :: CCache -> Reference -> IO Word64
baseCCache :: Bool -> IO CCache
lookupCode :: CCache -> Referent -> IO (Maybe Code)
resolveCode :: Reference -> Map Reference (SuperGroup Symbol) -> Map Reference Word64 -> EnumSet Word64 -> Maybe Code
cacheability :: Map Reference Word64 -> EnumSet Word64 -> Reference -> Cacheability
checkSandboxing :: CCache -> [Reference] -> Closure -> IO Bool
checkValueSandboxing :: CCache -> [Reference] -> Value -> IO (Either [Referent] [Referent])
codeValidate :: CCache -> [(Reference, SuperGroup Symbol)] -> IO (Maybe (Failure Text))

module Unison.Runtime.ANF.Serialize
data Version
Transfer :: Word32 -> Version
Hash :: Word32 -> Version
data TmTag
VarT :: TmTag
ForceT :: TmTag
AppT :: TmTag
HandleT :: TmTag
ShiftT :: TmTag
MatchT :: TmTag
LitT :: TmTag
NameRefT :: TmTag
NameVarT :: TmTag
LetDirT :: TmTag
LetIndT :: TmTag
BxLitT :: TmTag
data FnTag
FVarT :: FnTag
FCombT :: FnTag
FContT :: FnTag
FConT :: FnTag
FReqT :: FnTag
FPrimT :: FnTag
FForeignT :: FnTag
data MtTag
MIntT :: MtTag
MTextT :: MtTag
MReqT :: MtTag
MEmptyT :: MtTag
MDataT :: MtTag
MSumT :: MtTag
MNumT :: MtTag
data LtTag
IT :: LtTag
NT :: LtTag
FT :: LtTag
TT :: LtTag
CT :: LtTag
LMT :: LtTag
LYT :: LtTag
data BLTag
TextT :: BLTag
ListT :: BLTag
TmLinkT :: BLTag
TyLinkT :: BLTag
BytesT :: BLTag
QuoteT :: BLTag
CodeT :: BLTag
BArrT :: BLTag
PosT :: BLTag
NegT :: BLTag
CharT :: BLTag
FloatT :: BLTag
ArrT :: BLTag
CachedCodeT :: BLTag
data VaTag
PartialT :: VaTag
DataT :: VaTag
ContT :: VaTag
BLitT :: VaTag
data CoTag
KET :: CoTag
MarkT :: CoTag
PushT :: CoTag
index :: Eq v => [v] -> v -> Maybe Word64
deindex :: HasCallStack => [v] -> Word64 -> v
pushCtx :: [v] -> [v] -> [v]
putIndex :: MonadPut m => Word64 -> m ()
getIndex :: MonadGet m => m Word64
putVar :: MonadPut m => Eq v => [v] -> v -> m ()
getVar :: MonadGet m => [v] -> m v
putArgs :: MonadPut m => Eq v => [v] -> [v] -> m ()
getArgs :: MonadGet m => [v] -> m [v]
putCCs :: MonadPut m => [Mem] -> m ()
getCCs :: MonadGet m => m [Mem]
putGroup :: MonadPut m => Var v => Map Reference Word64 -> Map ForeignFunc Text -> SuperGroup v -> m ()
getGroup :: MonadGet m => Var v => m (SuperGroup v)
putCode :: MonadPut m => Map ForeignFunc Text -> Code -> m ()
getCode :: MonadGet m => Word32 -> m Code
putCacheability :: MonadPut m => Cacheability -> m ()
getCacheability :: MonadGet m => m Cacheability
putComb :: MonadPut m => Var v => Map Reference Word64 -> Map ForeignFunc Text -> [v] -> SuperNormal v -> m ()
getFresh :: Var v => Word64 -> v
getComb :: MonadGet m => Var v => [v] -> Word64 -> m (SuperNormal v)
putNormal :: MonadPut m => Var v => Map Reference Word64 -> Map ForeignFunc Text -> [v] -> ANormal v -> m ()
getNormal :: MonadGet m => Var v => [v] -> Word64 -> m (ANormal v)
putFunc :: MonadPut m => Var v => Map Reference Word64 -> Map ForeignFunc Text -> [v] -> Func v -> m ()
getFunc :: MonadGet m => Var v => [v] -> m (Func v)
putPOp :: MonadPut m => POp -> m ()
getPOp :: MonadGet m => m POp
pOpCode :: POp -> Word16
pOpAssoc :: [(POp, Word16)]
pop2word :: Map POp Word16
word2pop :: Map Word16 POp
putLit :: MonadPut m => Lit -> m ()
getLit :: MonadGet m => m Lit
putBLit :: MonadPut m => Version -> BLit -> m ()
getBLit :: MonadGet m => Version -> m BLit
putRefs :: MonadPut m => [Reference] -> m ()
getRefs :: MonadGet m => m [Reference]
putBranches :: MonadPut m => Var v => Map Reference Word64 -> Map ForeignFunc Text -> [v] -> Branched (ANormal v) -> m ()
getBranches :: MonadGet m => Var v => [v] -> Word64 -> m (Branched (ANormal v))
putCase :: MonadPut m => Var v => Map Reference Word64 -> Map ForeignFunc Text -> [v] -> ([Mem], ANormal v) -> m ()
getCase :: MonadGet m => Var v => [v] -> Word64 -> m ([Mem], ANormal v)
putCTag :: MonadPut m => CTag -> m ()
getCTag :: MonadGet m => m CTag
putGroupRef :: MonadPut m => GroupRef -> m ()
getGroupRef :: MonadGet m => m GroupRef
putValue :: MonadPut m => Version -> Value -> m ()
getValue :: MonadGet m => Version -> m Value
putCont :: MonadPut m => Version -> Cont -> m ()
getCont :: MonadGet m => Version -> m Cont
deserializeCode :: ByteString -> Either String Code
serializeCode :: Map ForeignFunc Text -> Code -> ByteString

-- | Serializes a <a>SuperGroup</a> for rehashing.
--   
--   Expected as arguments are some code, and the <a>Reference</a> that
--   refers to it. In particular, if the code refers to itself by
--   reference, or if the code is part of a mututally-recursive set of
--   definitions (which have a common hash), the reference used as part of
--   that (mutual) recursion must be supplied.
--   
--   Using that reference, we find all references in the code to that
--   connected component. In the resulting byte string, those references
--   are instead replaced by positions in a listing of the connected
--   component. This means that the byte string is independent of the hash
--   used for the self reference. Only the order matters (which is
--   determined by the <a>Reference</a>). Then the bytes can be re-hashed
--   to establish a new hash for the connected component. This operation
--   should be idempotent as long as the indexing is preserved.
--   
--   Supplying a <a>Builtin</a> reference is not supported. Such code
--   shouldn't be subject to rehashing.
serializeGroupForRehash :: Var v => Map ForeignFunc Text -> Reference -> SuperGroup v -> ByteString
getVersionedValue :: MonadGet m => m Value
deserializeValue :: ByteString -> Either String Value
serializeValue :: Value -> ByteString
serializeValueForHash :: Value -> ByteString
valueVersion :: Word32
codeVersion :: Word32
instance GHC.Show.Show Unison.Runtime.ANF.Serialize.Version
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.CoTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.VaTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.BLTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.LtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.MtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.FnTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.TmTag

module Unison.Runtime.ANF.Rehash
checkGroupHashes :: [(Referent, Code)] -> Either (Text, [Referent]) (Either [Referent] [Referent])
rehashGroups :: Map Reference (SuperGroup Symbol) -> Either (Text, [Referent]) (Map Reference Reference, Map Reference (SuperGroup Symbol))
checkMissing :: [(Referent, Code)] -> Either (Text, [Referent]) [Reference]
rehashSCC :: SCC (Reference, SuperGroup Symbol) -> (Map Reference Reference, Map Reference (SuperGroup Symbol))
checkSCC :: SCC (Reference, a) -> Bool

module Unison.Runtime.Foreign.Function
class ForeignConvention a
readAtIndex :: ForeignConvention a => Stack -> Int -> IO a
readsAt :: ForeignConvention a => Stack -> Args -> IO a
decodeVal :: ForeignConvention a => Val -> IO a
writeBack :: ForeignConvention a => Stack -> a -> IO ()
encodeVal :: ForeignConvention a => a -> Val
foreignCall :: ForeignFunc -> Args -> XStack -> IOEXStack
readsAtError :: String -> Args -> IO a
foreignConventionError :: String -> Val -> IO a
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Foreign.Function.StdHnd
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (Data.Either.Either a b)
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (GHC.Maybe.Maybe a)
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Int
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word8
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word16
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word32
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word64
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Char
instance Unison.Runtime.Foreign.Function.ForeignConvention ()
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c, Unison.Runtime.Foreign.Function.ForeignConvention d) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c, d)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c, Unison.Runtime.Foreign.Function.ForeignConvention d, Unison.Runtime.Foreign.Function.ForeignConvention e) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c, d, e)
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Runtime.Foreign.Failure a)
instance Unison.Runtime.Foreign.Function.ForeignConvention Data.Time.Clock.Internal.POSIXTime.POSIXTime
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Handle.Types.BufferMode
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.IOMode.IOMode
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Device.SeekMode
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Base.String
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Bool
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Double
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Stack.Val
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Stack.Closure
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Foreign.Foreign
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Sequence.Internal.Seq Unison.Runtime.Stack.Val)
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention [a]
instance Unison.Runtime.Foreign.BuiltinForeign b => Unison.Runtime.Foreign.Function.ForeignConvention b

module Unison.Runtime.Machine.Primops
prim1wrap :: ForeignConvention x => (Stack -> x -> IO ()) -> Stack -> Int -> IO Stack
prim1 :: CCache -> Stack -> Prim1 -> Int -> IO Stack
prim2wrap2 :: ForeignConvention x => ForeignConvention y => (Stack -> x -> y -> IO ()) -> Stack -> Int -> Int -> IO Stack
primxx :: CCache -> Stack -> Prim2 -> Int -> Int -> IO Stack
termLinkVal :: Referent -> Val
typeLinkVal :: Reference -> Val
deci :: Stack -> Int -> IO ()
decn :: Stack -> Word64 -> IO ()
inci :: Stack -> Int -> IO ()
incn :: Stack -> Word64 -> IO ()
trnc :: Stack -> Int -> IO ()
negi :: Stack -> Int -> IO ()
sgni :: Stack -> Int -> IO ()
absf :: Stack -> Double -> IO ()
ceil :: Stack -> Double -> IO ()
flor :: Stack -> Double -> IO ()
trnf :: Stack -> Double -> IO ()
rndf :: Stack -> Double -> IO ()
expf :: Stack -> Double -> IO ()
logf :: Stack -> Double -> IO ()
sqtf :: Stack -> Double -> IO ()
cosf :: Stack -> Double -> IO ()
sinf :: Stack -> Double -> IO ()
tanf :: Stack -> Double -> IO ()
cshf :: Stack -> Double -> IO ()
snhf :: Stack -> Double -> IO ()
tnhf :: Stack -> Double -> IO ()
acsf :: Stack -> Double -> IO ()
asnf :: Stack -> Double -> IO ()
atnf :: Stack -> Double -> IO ()
asnh :: Stack -> Double -> IO ()
acsh :: Stack -> Double -> IO ()
atnh :: Stack -> Double -> IO ()
itof :: Stack -> Int -> IO ()
ntof :: Stack -> Word64 -> IO ()
lzro :: Stack -> Word64 -> IO ()
tzro :: Stack -> Word64 -> IO ()
popc :: Stack -> Word64 -> IO ()
comn :: Stack -> Word64 -> IO ()
comi :: Stack -> Int -> IO ()
notb :: Stack -> Bool -> IO ()
sizt :: Stack -> Text -> IO ()
sizs :: Stack -> USeq -> IO ()
itot :: Stack -> Int -> IO ()
ntot :: Stack -> Word64 -> IO ()
ftot :: Stack -> Double -> IO ()
usnc :: Stack -> Text -> IO ()
ucns :: Stack -> Text -> IO ()
readIntegral :: (Bounded n, Integral n) => String -> Maybe n
clamp :: forall n. (Bounded n, Integral n) => Integer -> Maybe n
ttoi :: Stack -> Text -> IO ()
tton :: Stack -> Text -> IO ()
ttof :: Stack -> Text -> IO ()
vwls :: Stack -> USeq -> IO ()
vwrs :: Stack -> USeq -> IO ()
pakt :: Stack -> USeq -> IO ()
upkt :: Stack -> Text -> IO ()
pakb :: Stack -> USeq -> IO ()
upkb :: Stack -> Bytes -> IO ()
sizb :: Stack -> Bytes -> IO ()
fltb :: Stack -> Bytes -> IO ()
refr :: Stack -> IORef Val -> IO ()
refn :: Stack -> Val -> IO ()
rrfc :: CCache -> Stack -> IORef Val -> IO ()
tikr :: Stack -> Ticket Val -> IO ()
miss :: CCache -> Stack -> Referent -> IO ()
sdbl :: CCache -> Stack -> Referent -> IO ()
sandboxList :: CCache -> Referent -> IO [Reference]
lkup :: CCache -> Stack -> Referent -> IO ()
cvld :: CCache -> Stack -> [(Referent, Code)] -> IO ()
tltt :: Stack -> Referent -> IO ()
dbtx :: CCache -> Stack -> Val -> IO ()
addi :: Stack -> Int -> Int -> IO ()
subi :: Stack -> Int -> Int -> IO ()
muli :: Stack -> Int -> Int -> IO ()
divi :: Stack -> Int -> Int -> IO ()
modi :: Stack -> Int -> Int -> IO ()
eqli :: Stack -> Int -> Int -> IO ()
neqi :: Stack -> Int -> Int -> IO ()
leqi :: Stack -> Int -> Int -> IO ()
lesi :: Stack -> Int -> Int -> IO ()
andi :: Stack -> Int -> Int -> IO ()
iori :: Stack -> Int -> Int -> IO ()
xori :: Stack -> Int -> Int -> IO ()
shli :: Stack -> Int -> Int -> IO ()
shri :: Stack -> Int -> Int -> IO ()
powi :: Stack -> Int -> Word64 -> IO ()
addn :: Stack -> Word64 -> Word64 -> IO ()
subn :: Stack -> Word64 -> Word64 -> IO ()
muln :: Stack -> Word64 -> Word64 -> IO ()
divn :: Stack -> Word64 -> Word64 -> IO ()
modn :: Stack -> Word64 -> Word64 -> IO ()
shln :: Stack -> Word64 -> Int -> IO ()
shrn :: Stack -> Word64 -> Int -> IO ()
pown :: Stack -> Word64 -> Word64 -> IO ()
eqln :: Stack -> Word64 -> Word64 -> IO ()
neqn :: Stack -> Word64 -> Word64 -> IO ()
leqn :: Stack -> Word64 -> Word64 -> IO ()
lesn :: Stack -> Word64 -> Word64 -> IO ()
andn :: Stack -> Word64 -> Word64 -> IO ()
iorn :: Stack -> Word64 -> Word64 -> IO ()
xorn :: Stack -> Word64 -> Word64 -> IO ()
drpn :: Stack -> Word64 -> Word64 -> IO ()
eqlf :: Stack -> Double -> Double -> IO ()
neqf :: Stack -> Double -> Double -> IO ()
leqf :: Stack -> Double -> Double -> IO ()
lesf :: Stack -> Double -> Double -> IO ()
addf :: Stack -> Double -> Double -> IO ()
subf :: Stack -> Double -> Double -> IO ()
mulf :: Stack -> Double -> Double -> IO ()
divf :: Stack -> Double -> Double -> IO ()
atn2 :: Stack -> Double -> Double -> IO ()
powf :: Stack -> Double -> Double -> IO ()
logb :: Stack -> Double -> Double -> IO ()
maxf :: Stack -> Double -> Double -> IO ()
minf :: Stack -> Double -> Double -> IO ()
drpt :: Stack -> Int -> Text -> IO ()
takt :: Stack -> Int -> Text -> IO ()
catt :: Stack -> Text -> Text -> IO ()
ixot :: Stack -> Text -> Text -> IO ()
eqlt :: Stack -> Text -> Text -> IO ()
leqt :: Stack -> Text -> Text -> IO ()
lest :: Stack -> Text -> Text -> IO ()
eqlu :: Stack -> Val -> Val -> IO ()
cmpu :: Stack -> Val -> Val -> IO ()
lequ :: Stack -> Val -> Val -> IO ()
lesu :: Stack -> Val -> Val -> IO ()
drps :: Stack -> Int -> USeq -> IO ()
taks :: Stack -> Int -> USeq -> IO ()
cons :: Stack -> Val -> USeq -> IO ()
snoc :: Stack -> USeq -> Val -> IO ()
idxs :: Stack -> Int -> USeq -> IO ()
data SeqView a b
SeqViewEmpty :: SeqView a b
SeqViewElem :: a -> b -> SeqView a b
decodeSeqView :: ForeignConvention a => ForeignConvention b => Closure -> IO (SeqView a b)
seqViewE :: Closure
encodeSeqView :: ForeignConvention a => ForeignConvention b => SeqView a b -> Closure
spll :: Stack -> Int -> USeq -> IO ()
splr :: Stack -> Int -> USeq -> IO ()
cats :: Stack -> USeq -> USeq -> IO ()
takb :: Stack -> Int -> Bytes -> IO ()
drpb :: Stack -> Int -> Bytes -> IO ()
idxb :: Stack -> Int -> Bytes -> IO ()
catb :: Stack -> Bytes -> Bytes -> IO ()
ixob :: Stack -> Bytes -> Bytes -> IO ()
refw :: Stack -> IORef Val -> Val -> IO ()
cast :: Stack -> Int -> Int -> IO ()
andb :: Stack -> Bool -> Bool -> IO ()
iorb :: Stack -> Bool -> Bool -> IO ()
sdbv :: CCache -> Stack -> [Referent] -> Value -> IO ()
sdbx :: CCache -> Stack -> [Referent] -> Closure -> IO ()
closureNum :: Closure -> Int
universalEq :: (Foreign -> Foreign -> Bool) -> Val -> Val -> Bool
compareAsFloat :: Int -> Int -> Ordering
universalCompare :: (Foreign -> Foreign -> Ordering) -> Val -> Val -> Ordering
arrayCmp :: (a -> a -> Ordering) -> Array a -> Array a -> Ordering
arrayEq :: (a -> a -> Bool) -> Array a -> Array a -> Bool
matchTags :: PackedTag -> PackedTag -> Bool
matchUnboxedTypes :: UnboxedTypeTag -> UnboxedTypeTag -> Bool
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Runtime.Machine.Primops.SeqView a b)

module Unison.Runtime.Machine

-- | A ref storing every currently active thread. This is helpful for
--   cleaning up orphaned threads when the main process completes.
--   
--   We track threads when running in a host process like UCM, otherwise,
--   in one-off environments <a>Nothing</a> is used and we don't bother
--   tracking forked threads since they'll be cleaned up automatically on
--   process termination.
type ActiveThreads = Maybe (IORef (Set ThreadId))
data CCache
CCache :: Bool -> (Bool -> Val -> Tracer) -> TVar (EnumMap Word64 Combs) -> TVar (EnumMap Word64 MCombs) -> TVar (EnumMap Word64 Reference) -> TVar (EnumSet Word64) -> TVar (EnumMap Word64 Reference) -> TVar Word64 -> TVar Word64 -> TVar (Map Reference (SuperGroup Symbol)) -> TVar (Map Reference Word64) -> TVar (Map Reference Word64) -> TVar (Map Reference (Set Reference)) -> CCache
[$sel:sandboxed:CCache] :: CCache -> Bool
[$sel:tracer:CCache] :: CCache -> Bool -> Val -> Tracer
[$sel:srcCombs:CCache] :: CCache -> TVar (EnumMap Word64 Combs)
[$sel:combs:CCache] :: CCache -> TVar (EnumMap Word64 MCombs)
[$sel:combRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:cacheableCombs:CCache] :: CCache -> TVar (EnumSet Word64)
[$sel:tagRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:freshTm:CCache] :: CCache -> TVar Word64
[$sel:freshTy:CCache] :: CCache -> TVar Word64
[$sel:intermed:CCache] :: CCache -> TVar (Map Reference (SuperGroup Symbol))
[$sel:refTm:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:refTy:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:sandbox:CCache] :: CCache -> TVar (Map Reference (Set Reference))
type Combs = GCombs Void CombIx
data Tracer
NoTrace :: Tracer
MsgTrace :: String -> String -> String -> Tracer
SimpleTrace :: String -> Tracer
apply0 :: Maybe (XStack -> IO ()) -> CCache -> ActiveThreads -> Word64 -> IO ()
baseCCache :: Bool -> IO CCache
cacheAdd :: [(Reference, Code)] -> CCache -> IO [Reference]
cacheAdd0 :: Set Reference -> [(Reference, Code)] -> [(Reference, Set Reference)] -> CCache -> IO ()
eval0 :: CCache -> ActiveThreads -> MSection -> IO ()
expandSandbox :: Map Reference (Set Reference) -> [(Reference, SuperGroup Symbol)] -> [(Reference, Set Reference)]
preEvalTopLevelConstants :: EnumMap Word64 (GCombs Val CombIx) -> EnumMap Word64 (GCombs Val CombIx) -> CCache -> IO ()
refLookup :: String -> Map Reference Word64 -> Reference -> Word64
refNumTm :: CCache -> Reference -> IO Word64
refNumsTm :: CCache -> IO (Map Reference Word64)
refNumsTy :: CCache -> IO (Map Reference Word64)
reifyValue :: CCache -> Value -> IO (Either [Reference] Val)
resolveSection :: CCache -> Section -> IO MSection

module Unison.Runtime.Interface
startRuntime :: Bool -> RuntimeHost -> Text -> IO (Runtime Symbol)
withRuntime :: MonadUnliftIO m => Bool -> RuntimeHost -> Text -> (Runtime Symbol -> m a) -> m a
startNativeRuntime :: Text -> FilePath -> IO (Runtime Symbol)
standalone :: CCache -> Word64 -> IO StoredCache
runStandalone :: Bool -> StoredCache -> CombIx -> IO (Either (Pretty ColorText) ())

-- | A version of the Code Cache designed to be serialized to disk as
--   standalone bytecode.
data StoredCache
SCache :: EnumMap Word64 Combs -> EnumMap Word64 Reference -> EnumSet Word64 -> EnumMap Word64 Reference -> Word64 -> Word64 -> Map Reference (SuperGroup Symbol) -> Map Reference Word64 -> Map Reference Word64 -> Map Reference (Set Reference) -> StoredCache
decodeStandalone :: ByteString -> Either String (Text, Text, CombIx, StoredCache)

-- | Whether the runtime is hosted within a persistent session or as a
--   one-off process. This affects the amount of clean-up and book-keeping
--   the runtime does.
data RuntimeHost
OneOff :: RuntimeHost
Persistent :: RuntimeHost
data () => Runtime v
Runtime :: IO () -> (CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))) -> (CompileOpts -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)) -> Type v Ann -> NESet (Type v Ann) -> Runtime v
[$sel:terminate:Runtime] :: Runtime v -> IO ()
[$sel:evaluate:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))
[$sel:compileTo:Runtime] :: Runtime v -> CompileOpts -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)
[$sel:mainType:Runtime] :: Runtime v -> Type v Ann
[$sel:ioTestTypes:Runtime] :: Runtime v -> NESet (Type v Ann)
getStoredCache :: MonadGet m => m StoredCache
putStoredCache :: MonadPut m => StoredCache -> m ()
instance GHC.Classes.Eq Unison.Runtime.Interface.StoredCache
instance GHC.Show.Show Unison.Runtime.Interface.StoredCache
instance (GHC.Classes.Ord from, GHC.Classes.Ord to) => GHC.Base.Semigroup (Unison.Runtime.Interface.Remapping from to)
instance (GHC.Classes.Ord from, GHC.Classes.Ord to) => GHC.Base.Monoid (Unison.Runtime.Interface.Remapping from to)

module Unison.Runtime.Vector
data Vec a
[Scalar] :: a -> Vec a
[Vec] :: Unbox a => Vector a -> Vec a
[Pair] :: Vec a -> Vec b -> Vec (a, b)
[Choose] :: Vec Bool -> Vec a -> Vec a -> Vec a
[Mux] :: Vec Nat -> Vec (Vec a) -> Vec a
type Nat = Word64
mu :: Vec a -> Nat -> Maybe a
bound :: Nat -> Vec a -> Nat
toList :: Vec a -> [a]
